<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>es6 | 西索的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/picture.jpg">
    <link rel="manifest" href="/picture.jpg">
    <link rel="apple-touch-icon" href="/picture.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.69cc6ed9.css" as="style"><link rel="preload" href="/assets/js/app.a660b788.js" as="script"><link rel="preload" href="/assets/js/2.efd5ddf9.js" as="script"><link rel="preload" href="/assets/js/3.adeef9ff.js" as="script"><link rel="prefetch" href="/assets/js/10.3038f01f.js"><link rel="prefetch" href="/assets/js/11.c07d16cd.js"><link rel="prefetch" href="/assets/js/12.4b34605b.js"><link rel="prefetch" href="/assets/js/13.fad4767b.js"><link rel="prefetch" href="/assets/js/14.df4a5f73.js"><link rel="prefetch" href="/assets/js/15.4b386353.js"><link rel="prefetch" href="/assets/js/16.b432de6e.js"><link rel="prefetch" href="/assets/js/17.ae8b4193.js"><link rel="prefetch" href="/assets/js/4.e56f3ca9.js"><link rel="prefetch" href="/assets/js/5.06223f8f.js"><link rel="prefetch" href="/assets/js/6.bc465d58.js"><link rel="prefetch" href="/assets/js/7.5a53c1b3.js"><link rel="prefetch" href="/assets/js/8.6f04129e.js"><link rel="prefetch" href="/assets/js/9.73c62352.js">
    <link rel="stylesheet" href="/assets/css/0.styles.69cc6ed9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/picture.jpg" alt="西索的博客" class="logo"> <span class="site-name can-hide">西索的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="/note/note1/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="/poetry/" class="nav-link">
  诗和远方
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="/note/note1/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="/poetry/" class="nav-link">
  诗和远方
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/css/" class="sidebar-link">博客</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/css/" class="sidebar-link">css</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js/" class="sidebar-link">js</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/es6/" aria-current="page" class="active sidebar-link">es6</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/es6/#_1-eacmscript与javascript的关系" class="sidebar-link">1\. EACMScript与JavaScript的关系</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_2-babel-转码器" class="sidebar-link">2\. Babel 转码器</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_1-let-的特性以及用法" class="sidebar-link">1\. let 的特性以及用法</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_2-const-特性以及方法" class="sidebar-link">2\. const 特性以及方法</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_3-顶层对象属性" class="sidebar-link">3\. 顶层对象属性</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_1-对象的解构" class="sidebar-link">1\. 对象的解构</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_2-数组的解构" class="sidebar-link">2\. 数组的解构</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_3-参数的解构" class="sidebar-link">3\. 参数的解构</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_4-其他的解构" class="sidebar-link">4\. 其他的解构</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_1-更好的unicode支持" class="sidebar-link">1\. 更好的Unicode支持</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_2-增加的字符串api-只举出工作中常用的四种" class="sidebar-link">2\. 增加的字符串API(只举出工作中常用的四种)</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_3-模板字符串" class="sidebar-link">3\. 模板字符串</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）" class="sidebar-link">1\. 在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法" class="sidebar-link">ES6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法:</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_2-展开运算符：-要展开的东西" class="sidebar-link">2\. 展开运算符：...要展开的东西</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_3-明确函数的双重用途" class="sidebar-link">3\. 明确函数的双重用途</a></li><li class="sidebar-sub-header"><a href="/blog/es6/#_4-箭头函数" class="sidebar-link">4\. 箭头函数</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/" class="sidebar-link">vue</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/" class="sidebar-link">react</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/webpack/" class="sidebar-link">webpack</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="es6"><a href="#es6" class="header-anchor">#</a> es6</h1> <p>ES6总结篇（一）</p> <h1 id="第一章、eacmscript-6-简介"><a href="#第一章、eacmscript-6-简介" class="header-anchor">#</a> 第一章、EACMScript 6 简介</h1> <h2 id="_1-eacmscript与javascript的关系"><a href="#_1-eacmscript与javascript的关系" class="header-anchor">#</a> 1. EACMScript与JavaScript的关系</h2> <p>大家对JavaScript起源都有一定了解，这个就不再赘述，直接引用ES6的总结：</p> <div class="language- extra-class"><pre><code>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。
另外的 ECMAScript 方言还有 JScript 和ActionScript。日常场合，这两个词是可以互换的。
</code></pre></div><h2 id="_2-babel-转码器"><a href="#_2-babel-转码器" class="header-anchor">#</a> 2. Babel 转码器</h2> <ol><li><strong>Babel的作用</strong></li></ol> <ul><li><p>1.1 <strong>Babel</strong> babeljs.io/ 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行</p> <p>// 转码前
input.map(item =&gt; item + 1);</p> <p>// 转码后
input.map(function (item) {
return item + 1;
});</p></li></ul> <p>由于ES6有兼容性问题，导致有些语法糖不能在某些浏览器上正确执行，经过<strong>Babel</strong>转码之后变成大家都兼容的ES5，就可以正常执行了。</p> <ol start="2"><li><strong>安装以及配置</strong></li></ol> <ul><li><p>2.2.1 在项目的命令行安装 <code>$ npm install --save-dev @babel/core</code></p></li> <li><p>2.2.2 <strong>.babelrc文件</strong>用来设置转码规则和插件，基本规格如下：</p> <p>{
&quot;presets&quot;: [
&quot;@babel/env&quot;, //最新转码规则
&quot;@babel/preset-react&quot; //react 转码规则
],
&quot;plugins&quot;: []
}</p></li></ul> <p>presets字段设定转码规则： 官方提供以下的规则集(需要先安装再在**.babelrc文件**中使用，安装如下)</p> <div class="language- extra-class"><pre><code># 最新转码规则
$ npm install --save-dev @babel/preset-env
# react 转码规则
$ npm install --save-dev @babel/preset-reac
</code></pre></div><p><strong>注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。</strong></p> <ul><li><p>2.2.3 <strong>命令行工具@babel/cli、@babel/node、@babel/register</strong> 它的安装命令如下：</p> <p>$ npm install --save-dev @babel/cli
$ npm install --save-dev @babel/node #提供一个支持 ES6 的 REPL 环境
$ npm install --save-dev @babel/register
#改写require命令，为它加上一个钩子。
#每当使用require加载.js、.jsx、.es和.es6
#后缀名的文件，就会先用 Babel 进行转码</p></li></ul> <p>@babel/cli 基本用法（<strong>babel指令</strong>）：</p> <div class="language- extra-class"><pre><code># 转码结果输出到标准输出
$ npx babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ npx babel example.js --out-file compiled.js
# 或者
$ npx babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ npx babel src --out-dir lib
# 或者
$ npx babel src -d lib

# -s 参数生成source map文件
$ npx babel src -d lib -s
</code></pre></div><p>@babel/node 基本用法（<strong>babel-node指令</strong>）</p> <div class="language- extra-class"><pre><code>$ npx babel-node
&gt; (x =&gt; x * 2)(1)
2
</code></pre></div><p>@babel/register 基本用法</p> <div class="language- extra-class"><pre><code>//使用时必须首先加载@babel/register
require('@babel/register');
require('./es6.js');
</code></pre></div><ul><li><p>2.2.4 polyfill （用来转换babel无法转换的API以及一些语法） 使用core-js和<strong>regenerator-runtime(提供generator函数的转码)</strong>。</p></li> <li><p>安装：<code>$ npm install --save-dev core-js regenerator-runtime</code></p></li> <li><p>使用</p> <p>import 'core-js';
import 'regenerator-runtime/runtime';
// 或者
require('core-js');
require('regenerator-runtime/runtime);</p></li></ul> <p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="definitions.js">github.com/babel/babel…</a>文件</p> <ul><li><p><strong>浏览器环境</strong></p></li> <li><p>Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。</p></li></ul> <p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p> <p>Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p> <h1 id="第二章、let-和-const-命令"><a href="#第二章、let-和-const-命令" class="header-anchor">#</a> 第二章、let 和 const 命令</h1> <h2 id="_1-let-的特性以及用法"><a href="#_1-let-的特性以及用法" class="header-anchor">#</a> 1. let 的特性以及用法</h2> <ol><li>首先，我先总结一下<strong>var</strong>缺点</li></ol> <ul><li><p>1.1 允许重复的变量声明：导致数据被覆盖</p></li> <li><p>1.2 变量提升：怪异的数据访问、闭包问题</p></li> <li><p>1.3 全局变量挂载到全局对象：全局对象成员污染问题</p> <p>// 1. 允许重复的变量声明：导致数据被覆盖
var a = 1;
function print(){
console.log(a)
}
// 假设这里有一千行代码
var a = 2;
print(); // 2</p> <p>// 2. 变量提升：怪异的数据访问</p> <p>if (Math.random() &lt; 0.5) {
var a = &quot;abc&quot;;
console.log(a);
}
else {
console.log(a);
}
console.log(a); // 无论怎样访问都是abc</p> <p>// 3. 全局变量挂载到全局对象：全局对象成员污染问题</p> <p>var abc = &quot;123&quot;;
console.log(window.abc); // 123</p> <p>// var console = &quot;abc&quot;;
// console.log(console) // abc 这个很可怕</p></li></ul> <ol start="2"><li>let (完美的解决了这些问题)
<ol><li>let声明的变量不会挂载到全局对象</li> <li>let声明的变量，不允许当前作用域范围内重复声明</li> <li>使用let不会有变量提升，因此，不能在定义let变量之前使用它(形成暂时性死区)</li></ol></li></ol> <ul><li><p><strong>暂时性死区</strong>：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></li> <li><p><strong>块级作用域</strong>：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域</p> <p>// 1. let声明的变量不会挂载到全局对象</p> <p>let a = 123;
console.log(window.a) // undefined</p> <p>// 2. let声明的变量，不允许当前作用域范围内重复声明</p> <p>if (Math.random() &lt; 0.5) {
let a = 123; //定义在当前块级作用域
console.log(a) //当前块级作用域中的a
} else {
//这是另外一个块级作用域，该作用域中找不到a
console.log(a)
}</p> <p>//3. 使用let不会有变量提升，因此，不能在定义let变量之前使用它</p> <p>console(c); // Uncaught ReferenceError: c is not defined 形成了暂时性死区
let c = 6;</p></li></ul> <p><strong>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p> <h2 id="_2-const-特性以及方法"><a href="#_2-const-特性以及方法" class="header-anchor">#</a> 2. const 特性以及方法</h2> <ul><li>const和let完全相同，仅在于用const声明的变量，必须在声明时赋值，而且不可以重新赋值。（这里就不再举例其使用了）</li> <li>实际上，在开发中，应该尽量使用const来声明变量，以保证变量的值不会随意篡改，原因：</li></ul> <ol><li>根据经验，开发中的很多变量，都是不会更改，也不应该更改的。</li> <li>后续的很多框架或者是第三方JS库，都要求数据不可变，使用常量可以一定程度上保证这一点。</li></ol> <p><strong>注意</strong></p> <ol><li><p>常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变</p></li> <li><p>常量的命名</p> <ol><li>特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率、月地距地或其他一些绝不可能变化的配置。通常，<strong>该常量的名称全部使用大写，多个单词之间用下划线分割</strong></li> <li>普通的常量：使用和之前一样的命名即可</li></ol></li> <li><p>在for循环中，循环变量不可以使用常量，只能用let 关于主义的第一点，我举个例子</p> <p>const a = {
name: &quot;kevin&quot;,
age: 123
};
a.name = &quot;abc&quot;;
console.log(a) // abc</p> <p>// const PI = 3.14;
// const MOON_EARTH_DISTANCE = 3245563424; //月地距离</p></li></ol> <h2 id="_3-顶层对象属性"><a href="#_3-顶层对象属性" class="header-anchor">#</a> 3. 顶层对象属性</h2> <ol><li><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象</p> <p>var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1</p> <p>let b = 1;
window.b // undefined let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</p></li> <li><p>globalThis 对象 因为环境的不同，顶层对象在各种实现里面是不统一的</p> <ol><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li> <li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li> <li>Node 里面，顶层对象是global，但其他环境都不支持。 在不同环境中获取顶层对象的this ES6 提供了两个方法</li></ol> <p>// 方法一
(typeof window !== 'undefined'
? window
: (typeof process === 'object' &amp;&amp;
typeof require === 'function' &amp;&amp;
typeof global === 'object')
? global
: this);</p> <p>// 方法二
var getGlobal = function () {
if (typeof self !== 'undefined') { return self; }
if (typeof window !== 'undefined') { return window; }
if (typeof global !== 'undefined') { return global; }
throw new Error('unable to locate global object');
};</p></li></ol> <p>而且，ES6最后提到：</p> <ul><li>ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</li> <li>垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。</li></ul> <h1 id="第三章、变量的解构赋值"><a href="#第三章、变量的解构赋值" class="header-anchor">#</a> 第三章、变量的解构赋值</h1> <ul><li>在此，我这里主要介绍工作中我们常用的几种解构赋值：</li></ul> <ol><li>对象的解构</li> <li>数组的解构</li> <li>参数的解构</li> <li>其他的解构</li></ol> <h2 id="_1-对象的解构"><a href="#_1-对象的解构" class="header-anchor">#</a> 1. 对象的解构</h2> <p><strong>1. 什么是解构</strong></p> <ul><li><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） <strong>解构不会对被解构的目标造成任何影响</strong></p></li> <li><p><strong>在解构中使用默认值</strong></p> <p>{同名变量 = 默认值}
const user = {
name: &quot;kevin&quot;,
age: 11,
sex: &quot;男&quot;,
address: {
province: &quot;四川&quot;,
city: &quot;成都&quot;
}
}
//解构出user中的name、province
//定义两个变量name、province
//再解构
const { name, address: { province } } = user;
console.log(name, province)
// name: kevin  province: 四川</p></li> <li><p><strong>非同名属性解构</strong></p> <p>{属性名:变量名}
let obj = {};
let arr = [];
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
obj // {prop:123}
arr // [true]
//如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错</p> <p>let {foo: {bar}} = {baz: 'baz'};
// 报错</p></li></ul> <h2 id="_2-数组的解构"><a href="#_2-数组的解构" class="header-anchor">#</a> 2. 数组的解构</h2> <div class="language- extra-class"><pre><code>let [a, b, c] = [1, 2, 3];
// a:1 b:2 c:3
</code></pre></div><p>这种写法属于<strong>模式匹配</strong>，只要等号两边的模式相同，左边的变量就会被赋予对应的值</p> <ul><li><p>下面一些使用嵌套数组进行解构的例子以及一些情况</p> <p>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1    bar // 2    baz // 3</p> <p>let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;</p> <p>// 1. 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
let [x, y] = [1, 2, 3];
x // 1  y // 2</p> <p>let [a, [b], d] = [1, [2, 3], 4];
a // 1  b // 2  d // 4
// 2. 数组解构出 值和数组（运用扩展运算符... 在接下来的章节里会就介绍到）</p> <p>let [head, ...tail] = [1, 2, 3, 4];
head // 1   tail // [2, 3, 4]</p> <p>// 3. 如果解构不成功，变量的值就等于undefined。</p> <p>let [x, y, ...z] = ['a'];
x // &quot;a&quot;    y // undefined  z // []</p> <p>// 4. 如果等号的右边不是数组（或者严格地说，不是可遍历的解构，参见《Iterator》一章），那么将会报错。</p> <p>// 4.1 要么转为对象以后不具备 Iterator 接口</p> <p>let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;</p> <p>// 4.2 本身就不具备 Iterator 接口</p> <p>let [foo] = {};</p></li></ul> <p>从最后的例子可以看出，只要某种数据解构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p> <div class="language- extra-class"><pre><code>function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</code></pre></div><p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p> <h2 id="_3-参数的解构"><a href="#_3-参数的解构" class="header-anchor">#</a> 3. 参数的解构</h2> <p>废话不多说，直接上例子</p> <div class="language- extra-class"><pre><code>function add([x, y]){
  return x + y;
}
add([1, 2]); // 3
// 函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。
// 对于函数内部的代码来说，它们能感受到的参数就是x和y。
</code></pre></div><p>箭头函数也可以解构赋值</p> <div class="language- extra-class"><pre><code>[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
// [ 3, 7 ]
</code></pre></div><p>函数参数的解构也可以使用<strong>默认值</strong> 在第五章会给出介绍</p> <div class="language- extra-class"><pre><code>function move({x = 0, y = 0} = {}) { //x y 在参数上设置默认值
  return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
// 函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。
// 如果解构失败，x和y等于默认值。
</code></pre></div><p>undefined就会触发函数参数的默认值。</p> <div class="language- extra-class"><pre><code>[1, undefined, 3].map((x = 'yes') =&gt; x);
// [ 1, 'yes', 3 ]
</code></pre></div><h2 id="_4-其他的解构"><a href="#_4-其他的解构" class="header-anchor">#</a> 4. 其他的解构</h2> <ol><li><p>对象的解构也可以指定默认值 设置<strong>默认值</strong></p> <p>var {x = 3} = {};
x // 3</p> <p>var {x, y = 5} = {x: 1};
x // 1
y // 5</p> <p>var {x: y = 3} = {};
y // 3</p> <p>var {x: y = 3} = {x: 5};
y // 5</p> <p>var { message: msg = 'Something went wrong' } = {};
msg // &quot;Something went wrong&quot;</p></li></ol> <ul><li><p>默认值生效的条件是，对象的属性值严格等于undefined。</p> <p>var {x = 3} = {x: undefined};
x // 3</p> <p>var {x = 3} = {x: null};
x // null  因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效</p></li></ul> <p><strong>注意点</strong></p> <ol><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p> <p>// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。
// 只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。
// 正确的写法
let x;
({x} = {x: 1});</p></li> <li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式</p> <p>({} = [true, false]);
({} = 'abc');
({} = []);</p></li> <li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p> <p>let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3</p></li></ol> <h1 id="第四章、字符串的扩展"><a href="#第四章、字符串的扩展" class="header-anchor">#</a> 第四章、字符串的扩展</h1> <h2 id="_1-更好的unicode支持"><a href="#_1-更好的unicode支持" class="header-anchor">#</a> 1. 更好的Unicode支持</h2> <p>首先，介绍一下码元：</p> <ol><li>早期，由于存储空间宝贵，Unicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个<strong>码元（Code Unit）</strong>。后来，由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展到了32位（占用两个码元），并且，将某个文字对应的二进制数字叫做<strong>码点（Code Point）</strong>。</li></ol> <p>ES6为了解决这个困扰，为字符串提供了方法：codePointAt，根据字符串码元的位置得到其码点。</p> <p>同时，ES6为正则表达式添加了一个flag: u，如果添加了该配置，则匹配时，使用码点匹配</p> <div class="language- extra-class"><pre><code>const text = &quot;𠮷&quot;; //占用了两个码元（32位）

console.log(&quot;字符串长度：&quot;, text.length); // 2
console.log(&quot;使用正则测试：&quot;, /^.$/u.test(text)); // true
console.log(&quot;得到第一个码元：&quot;, text.charCodeAt(0)); // 55362
console.log(&quot;得到第二个码元：&quot;, text.charCodeAt(1)); // 57271

//𠮷：\ud842\udfb7
console.log(&quot;得到第一个码点：&quot;, text.codePointAt(0)); // 134071
console.log(&quot;得到第二个码点：&quot;, text.codePointAt(1)); // 57271
</code></pre></div><p>然后我们完成一个自己的<strong>判断字符串char，是32位，还是16位</strong>方法</p> <div class="language- extra-class"><pre><code>function is32bit(char, i) {
    //如果码点大于了16位二进制的最大值，则其是32位的
    return char.codePointAt(i) &gt; 0xffff;
}
</code></pre></div><p>得到一个字符串码点的真实长度</p> <div class="language- extra-class"><pre><code>function getLengthOfCodePoint(str) {
    var len = 0;
    for (let i = 0; i &lt; str.length; i++) {
        //i在索引码元
        if (is32bit(str, i)) {
            //当前字符串，在i这个位置，占用了两个码元
            i++;
        }
        len++;
    }
    return len;
}

console.log(&quot;𠮷是否是32位的：&quot;, is32bit(&quot;𠮷&quot;, 0)) // 𠮷是否是32位的： true
console.log(&quot;ab𠮷ab的码点长度：&quot;, getLengthOfCodePoint(&quot;ab𠮷ab&quot;)) // ab𠮷ab的码点长度： 5
</code></pre></div><h2 id="_2-增加的字符串api-只举出工作中常用的四种"><a href="#_2-增加的字符串api-只举出工作中常用的四种" class="header-anchor">#</a> 2. 增加的字符串API(只举出工作中常用的四种)</h2> <ul><li><p>includes 判断字符串中是否包含指定的子字符串</p></li> <li><p>startsWith 判断字符串中是否以指定的字符串开始</p></li> <li><p>endsWith 判断字符串中是否以指定的字符串结尾</p></li> <li><p>repeat 将字符串重复指定的次数，然后返回一个新字符串</p> <p>const text = &quot;我真是狠人&quot;;</p> <p>console.log(&quot;是否包含“狠”：&quot;, text.includes(&quot;狠&quot;));
console.log(&quot;是否以“我”开头：&quot;, text.startsWith(&quot;我&quot;));
console.log(&quot;是否以“狠人”结尾：&quot;,</p> <p>text.endsWith(&quot;狠人&quot;));
console.log(&quot;重复4次：&quot;, text.repeat(4));
// 由于过于简单，就不把console结果展示啦，有兴趣的可以直接试一下，哈哈哈</p></li></ul> <h2 id="_3-模板字符串"><a href="#_3-模板字符串" class="header-anchor">#</a> 3. 模板字符串</h2> <p><strong>模板字符串是此章节的灵魂</strong></p> <ul><li>ES6之前处理字符串繁琐的两个方面：</li></ul> <ol><li>多行字符串</li> <li>字符串拼接</li></ol> <ul><li>在ES6中，提供了模板字符串的书写，可以非常方便的换行和拼接，要做的，仅仅是将字符串的开始或结尾改为 ` 符号</li></ul> <p>如果要在字符串中拼接js表达式，只需要在模板字符串中使用<code>${JS表达式}</code></p> <div class="language- extra-class"><pre><code>var love1 = &quot;秋葵&quot;;
var love2 = &quot;香菜&quot;;

var text = `A喜欢${love1}
B也喜欢${love2}
表达式可以是任何有意义的数据${1 + 3 * 2 / 0.5}
表达式是可以嵌套的：${`表达式中的模板字符串${love1 + love2}`}
\n\n
奥布瓦的发顺丰
在模板字符串中使用\${JS表达式}可以进行插值
`;

console.log(text);
</code></pre></div><p>在模板字符串书写之前，可以加上标记:</p> <div class="language- extra-class"><pre><code>标记名`模板字符串`
</code></pre></div><p>标记是一个函数，函数参数如下：</p> <ol><li><p>参数1：被插值分割的字符串数组</p></li> <li><p>后续参数：所有的插值</p> <p>var love1 = &quot;秋葵&quot;;
var love2 = &quot;香菜&quot;;</p> <p>var text = myTag<code>邓哥喜欢${love1}，邓哥也喜欢${love2}。</code>;</p> <p>//相当于：
// text = myTag([&quot;A喜欢&quot;, &quot;，B也喜欢&quot;, &quot;。&quot;], &quot;秋葵&quot;, &quot;香菜&quot;)</p> <p>function myTag(parts) {
const values = Array.prototype.slice.apply(arguments).slice(1);
let str = &quot;&quot;;
for (let i = 0; i &lt; values.length; i++) {
str += <code>${parts[i]}：${values[i]}</code>;
if (i === values.length - 1) {
str += parts[i + 1];
}
}
return str;
}</p> <p>console.log(text); //A喜欢：秋葵，B也喜欢：香菜</p></li></ol> <h1 id="第五章、函数的扩展"><a href="#第五章、函数的扩展" class="header-anchor">#</a> 第五章、函数的扩展</h1> <h2 id="_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）"><a href="#_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）" class="header-anchor">#</a> 1. 在书写形参时，直接给形参赋值，附的值即为<strong>默认值</strong>（在解构的时候有过应用）</h2> <p>这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是undefined），则会自动使用默认值</p> <ol><li>留意暂时性死区 形参</li></ol> <ul><li>和ES6中的let或const声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。</li></ul> <ol start="2"><li>对arguments的影响</li></ol> <ul><li><p>只要给函数加上参数默认值，该函数会自动变量严格模式下的规则：arguments和形参脱离</p></li> <li><p>暂时性死区</p> <p>function test(a = b, b) {
console.log(a, b);
}
test(undefined, 2);// 报错 因为传a值undefined, 然后会给a赋默认值 b ,但是此时 b还没有赋值，所以报错。在上边解构赋值中也介绍过</p> <p>function sum(a, b = 1, c = 2) {
return a + b + c;
}</p> <p>console.log(sum(10, undefined, undefined))
console.log(sum(11))
console.log(sum(1, undefined, 5))  // 这种情况才是正常</p></li> <li><p>对arguments的影响</p> <p>function test(a, b = 1) {
console.log(&quot;arugments&quot;, arguments[0], arguments[1]); //arugments 1 2
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b); //a: 1 b: 2
a = 3;
console.log(&quot;arugments&quot;, arguments[0], arguments[1]); //arugments 1 2
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b); //a: 3 b: 2
}</p> <p>test(1, 2);</p></li></ul> <h2 id="es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法"><a href="#es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法" class="header-anchor">#</a> ES6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法:</h2> <div class="language- extra-class"><pre><code>function (...形参名){

}
</code></pre></div><p><strong>注意：</strong></p> <ol><li><p>一个函数，仅能出现一个剩余参数</p></li> <li><p>一个函数，如果有剩余参数，剩余参数必须是最后一个参数</p> <p>function test(a, b, ...args) {
console.log(a, b, args);
}</p> <p>test(1, 32, 46, 7, 34); //1 32 [46, 7, 34]</p></li></ol> <h2 id="_2-展开运算符：-要展开的东西"><a href="#_2-展开运算符：-要展开的东西" class="header-anchor">#</a> 2. 展开运算符：<code>...要展开的东西</code></h2> <div class="language- extra-class"><pre><code>const arr1 = [3, 67, 8, 5];

//克隆arr1数组到arr2

const arr2 = [0, ...arr1, 1];

console.log(arr2, arr1 === arr2)
// -------------------------------------
const obj1 = {
    name: &quot;A&quot;,
    age: 18,
    love: &quot;B&quot;,
    address: {
        country: &quot;中国&quot;,
        province: &quot;BJ&quot;,
        city: &quot;BJ&quot;
    }
}

// 浅克隆到obj2

const obj2 = {
    ...obj1,
    name: &quot;C&quot;
};

console.log(obj2)

console.log(obj1.address === obj2.address)
</code></pre></div><h2 id="_3-明确函数的双重用途"><a href="#_3-明确函数的双重用途" class="header-anchor">#</a> 3. 明确函数的双重用途</h2> <p>ES6提供了一个特殊的API，可以使用该API在函数内部，判断该函数是否使用了new来调用</p> <div class="language- extra-class"><pre><code>new.target 
//该表达式，得到的是：如果没有使用new来调用函数，则返回undefined
//如果使用new调用函数，则得到的是new关键字后面的函数本身

function Person(firstName, lastName) {
    //判断是否是使用new的方式来调用的函数

    // //过去的判断方式
    // if (!(this instanceof Person)) {
    //     throw new Error(&quot;该函数没有使用new来调用&quot;)
    // }

    if (new.target === undefined) {
        throw new Error(&quot;该函数没有使用new来调用&quot;)
    }
    this.firstName = firstName;
    this.lastName = lastName;
    this.fullName = `${firstName} ${lastName}`;
}

const p1 = new Person(&quot;张&quot;, &quot;三&quot;);
console.log(p1)



const p2 = Person(&quot;张&quot;, &quot;三&quot;);
console.log(p2); // 报错，该函数没有使用new来调用

const p3 = Person.call(p1, &quot;张&quot;, &quot;三&quot;)
console.log(p3);// 报错，该函数没有使用new来调用
</code></pre></div><h2 id="_4-箭头函数"><a href="#_4-箭头函数" class="header-anchor">#</a> 4. 箭头函数</h2> <ol><li><p>ES5中this的问题（本文主要是来介绍ES6的，暂且将之前的总结直接放在这里，在之后的博文中会仔细描述一下ES5系列）</p> <ol><li>通过对象调用函数，this指向对象</li> <li>直接调用函数，this指向全局对象</li> <li>如果通过new调用函数，this指向新创建的对象</li> <li>如果通过apply、call、bind调用函数，this指向指定的数据</li> <li>如果是DOM事件函数，this指向事件源</li></ol></li> <li><p>箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数</p></li></ol> <p>完整语法：</p> <div class="language- extra-class"><pre><code>(参数1, 参数2, ...)=&gt;{
    //函数体
}
</code></pre></div><p>如果参数只有一个，可以省略小括号</p> <div class="language- extra-class"><pre><code>参数 =&gt; {

}
</code></pre></div><p>如果箭头函数只有一条返回语句，可以省略大括号，和return关键字</p> <div class="language- extra-class"><pre><code>参数 =&gt; 返回值


const print = num =&gt; {
    console.log(&quot;给我的数字是：&quot;, num)
}
print(2);

const arr = [1,2,4,56,22,43,23,2,23,12,1];
arr.sort((a, b)=&gt; a - b);
console.log(arr);
</code></pre></div><p><strong>注意</strong></p> <ul><li><p>箭头函数中，不存在this、arguments、new.target，如果使用了，则使用的是函数外层的对应的this、arguments、new.target 也就是说<strong>在箭头函数中，this是固定的。因为箭头函数本身就是引用的外层函数的this</strong></p></li> <li><p>箭头函数没有原型</p></li> <li><p>箭头函数不能作用构造函数使用</p></li> <li><p>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</p> <p>// ES6
function foo() {
setTimeout(() =&gt; {
console.log('id:', this.id);
}, 100);
}</p> <p>// ES5
function foo() {
var _this = this;</p> <p>setTimeout(function () {
console.log('id:', _this.id);
}, 100);
}</p></li></ul> <p>除了this，arguments、super、new.target这三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p> <div class="language- extra-class"><pre><code>function foo() {
  setTimeout(() =&gt; {
    console.log('args:', arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
</code></pre></div><p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p> <div class="language- extra-class"><pre><code>(function() {
  return [
    (() =&gt; this.x).bind({ x: 'inner' })()
  ];
}).call({ x: 'outer' });
// ['outer']
//代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。
</code></pre></div><p><strong>应用比较多的场景</strong></p> <ol><li>临时性使用的函数，并不会可以调用它，比如：
<ol><li>事件处理函数</li> <li>异步处理函数</li> <li>其他临时性的函数</li></ol></li> <li>为了绑定外层this的函数</li> <li>在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数</li></ol> <p>本文主要引用阮一峰老师的《ECMAScript6简介》</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/js/" class="prev">
        js
      </a></span> <span class="next"><a href="/blog/vue/">
        vue
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a660b788.js" defer></script><script src="/assets/js/2.efd5ddf9.js" defer></script><script src="/assets/js/3.adeef9ff.js" defer></script>
  </body>
</html>
