<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue相关 | 西索的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/picture.jpg">
    <link rel="manifest" href="/picture.jpg">
    <link rel="apple-touch-icon" href="/picture.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.69cc6ed9.css" as="style"><link rel="preload" href="/assets/js/app.a660b788.js" as="script"><link rel="preload" href="/assets/js/2.efd5ddf9.js" as="script"><link rel="preload" href="/assets/js/12.4b34605b.js" as="script"><link rel="prefetch" href="/assets/js/10.3038f01f.js"><link rel="prefetch" href="/assets/js/11.c07d16cd.js"><link rel="prefetch" href="/assets/js/13.fad4767b.js"><link rel="prefetch" href="/assets/js/14.df4a5f73.js"><link rel="prefetch" href="/assets/js/15.4b386353.js"><link rel="prefetch" href="/assets/js/16.b432de6e.js"><link rel="prefetch" href="/assets/js/17.ae8b4193.js"><link rel="prefetch" href="/assets/js/3.adeef9ff.js"><link rel="prefetch" href="/assets/js/4.e56f3ca9.js"><link rel="prefetch" href="/assets/js/5.06223f8f.js"><link rel="prefetch" href="/assets/js/6.bc465d58.js"><link rel="prefetch" href="/assets/js/7.5a53c1b3.js"><link rel="prefetch" href="/assets/js/8.6f04129e.js"><link rel="prefetch" href="/assets/js/9.73c62352.js">
    <link rel="stylesheet" href="/assets/css/0.styles.69cc6ed9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/picture.jpg" alt="西索的博客" class="logo"> <span class="site-name can-hide">西索的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="/note/note1/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="/poetry/" class="nav-link">
  诗和远方
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  技术文档
</a></div><div class="nav-item"><a href="/note/note1/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="/poetry/" class="nav-link">
  诗和远方
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/css/" class="sidebar-link">博客</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/css/" class="sidebar-link">css</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js/" class="sidebar-link">js</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/es6/" class="sidebar-link">es6</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vue/" aria-current="page" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/#_1-require-context" class="sidebar-link">1.require.context()</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_2-watch" class="sidebar-link">2.watch</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-11种组件通讯" class="sidebar-link">3\. 11种组件通讯</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-1-props" class="sidebar-link">3.1 props</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-2-emit" class="sidebar-link">3.2 $emit</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-3-vuex" class="sidebar-link">3.3 vuex</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-4-attrs和listeners" class="sidebar-link">3.4 attrs和listeners</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-5-provide和inject" class="sidebar-link">3.5 provide和inject</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-6-parent和children" class="sidebar-link">3.6 parent和children</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-7-refs" class="sidebar-link">3.7 $refs</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-8-root" class="sidebar-link">3.8 $root</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-9-sync" class="sidebar-link">3.9 .sync</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-10-eventbus" class="sidebar-link">3.10 EventBus</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_3-11-路由传参" class="sidebar-link">3.11 路由传参</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_4-render-函数" class="sidebar-link">4.render 函数</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_5-异步组件" class="sidebar-link">5.异步组件</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_6-动态组件" class="sidebar-link">6.动态组件</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_7-递归组件" class="sidebar-link">7.递归组件</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_8-函数式组件" class="sidebar-link">8.函数式组件</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_9-components和-vue-component" class="sidebar-link">9.components和 Vue.component</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_10-vue-extend" class="sidebar-link">10.Vue.extend</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_11-mixins" class="sidebar-link">11.mixins</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_12-extends" class="sidebar-link">12.extends</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_13-vue-use" class="sidebar-link">13.Vue.use()</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_14-install" class="sidebar-link">14.install</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_15-vue-nexttick" class="sidebar-link">15.Vue.nextTick</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_16-vue-directive" class="sidebar-link">16.Vue.directive</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_17-vue-filter" class="sidebar-link">17.Vue.filter</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_18-vue-compile" class="sidebar-link">18.Vue.compile</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_19-vue-version" class="sidebar-link">19.Vue.version</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_20-vue-set" class="sidebar-link">20.Vue.set()</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_21-vue-config-keycodes" class="sidebar-link">21.Vue.config.keyCodes</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_22-vue-config-performance" class="sidebar-link">22.Vue.config.performance</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_23-vue-config-errorhandler" class="sidebar-link">23.Vue.config.errorHandler</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_24-vue-config-warnhandler" class="sidebar-link">24.Vue.config.warnHandler</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_25-v-once" class="sidebar-link">25.v-once</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_26-事件修饰符" class="sidebar-link">26.事件修饰符</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_27-按键修饰符和按键码" class="sidebar-link">27.按键修饰符和按键码</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_28-vue-router" class="sidebar-link">28.Vue-router</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_29-object-freeze" class="sidebar-link">29.Object.freeze</a></li><li class="sidebar-sub-header"><a href="/blog/vue/#_30-为路径设置别名" class="sidebar-link">30.为路径设置别名</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/" class="sidebar-link">react</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/webpack/" class="sidebar-link">webpack</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue相关"><a href="#vue相关" class="header-anchor">#</a> vue相关</h1> <h2 id="_1-require-context"><a href="#_1-require-context" class="header-anchor">#</a> 1.require.context()</h2> <p>1.场景:如页面需要导入多个组件,原始写法:</p> <div class="language- extra-class"><pre><code>import titleCom from '@/components/home/titleCom'
import bannerCom from '@/components/home/bannerCom'
import cellCom from '@/components/home/cellCom'
components:{titleCom,bannerCom,cellCom}
</code></pre></div><p>2.这样就写了大量重复的代码,利用 require.context 可以写成</p> <div class="language- extra-class"><pre><code>const path = require('path')
const files = require.context('@/components/home', false, /\.vue$/)
const modules = {}
files.keys().forEach(key =&gt; {
const name = path.basename(key, '.vue')
modules[name] = files(key).default || files(key)
})
components:modules
</code></pre></div><p>这样不管页面引入多少组件,都可以使用这个方法</p> <p>3.API 方法</p> <div class="language- extra-class"><pre><code>实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用
require.context(directory,useSubdirectories,regExp)
接收三个参数:
directory：说明需要检索的目录
useSubdirectories：是否检索子目录
regExp: 匹配文件的正则表达式,一般是文件名
</code></pre></div><h2 id="_2-watch"><a href="#_2-watch" class="header-anchor">#</a> 2.watch</h2> <p>2.1 常用用法
1.场景:表格初始进来需要调查询接口 getList(),然后input 改变会重新查询</p> <div class="language- extra-class"><pre><code>created(){
  this.getList()
},
watch: {
  inpVal(){
    this.getList()
  }
}
</code></pre></div><p>2.2 立即执行
2.可以直接利用 watch 的immediate和handler属性简写</p> <div class="language- extra-class"><pre><code>watch: {
  inpVal:{
    handler: 'getList',
      immediate: true
  }
}
</code></pre></div><p>2.3 深度监听
3.watch 的 deep 属性,深度监听,也就是监听复杂数据类型</p> <div class="language- extra-class"><pre><code>watch:{
  inpValObj:{
    handler(newVal,oldVal){
      console.log(newVal)
      console.log(oldVal)
    },
    deep:true
  }
}
</code></pre></div><p>此时发现oldVal和 newVal 值一样; 因为它们索引同一个对象/数组,Vue 不会保留修改之前值的副本; 所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化</p> <h2 id="_3-11种组件通讯"><a href="#_3-11种组件通讯" class="header-anchor">#</a> 3. 11种组件通讯</h2> <h2 id="_3-1-props"><a href="#_3-1-props" class="header-anchor">#</a> 3.1 props</h2> <p>这个应该非常属性,就是父传子的属性; props 值可以是一个数组或对象;</p> <div class="language- extra-class"><pre><code>// 数组:不建议使用
props:[]

// 对象
props:{
 inpVal:{
  type:Number, //传入值限定类型
  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol
  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认
  required: true, //是否必传
  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[]
  validator:(value) {
    // 这个值必须匹配下列字符串中的一个
    return ['success', 'warning', 'danger'].indexOf(value) == -1
  }
 }
}
</code></pre></div><h2 id="_3-2-emit"><a href="#_3-2-emit" class="header-anchor">#</a> 3.2 $emit</h2> <p>这个也应该非常常见,触发子组件触发父组件给自己绑定的事件,其实就是子传父的方法</p> <div class="language- extra-class"><pre><code>// 父组件
&lt;home @title=&quot;title&quot;&gt;
// 子组件
this.$emit('title',[{title:'这是title'}])
</code></pre></div><h2 id="_3-3-vuex"><a href="#_3-3-vuex" class="header-anchor">#</a> 3.3 vuex</h2> <p>1.这个也是很常用的,vuex 是一个状态管理器 2.是一个独立的插件,适合数据共享多的项目里面,因为如果只是简单的通讯,使用起来会比较重 3.API</p> <div class="language- extra-class"><pre><code>state:定义存贮数据的仓库 ,可通过this.$store.state 或mapState访问
getter:获取 store 值,可认为是 store 的计算属性,可通过this.$store.getter 或
       mapGetters访问
mutation:同步改变 store 值,为什么会设计成同步,因为mutation是直接改变 store 值,
         vue 对操作进行了记录,如果是异步无法追踪改变.可通过mapMutations调用
action:异步调用函数执行mutation,进而改变 store 值,可通过 this.$dispatch或mapActions
       访问
modules:模块,如果状态过多,可以拆分成模块,最后在入口通过...解构引入
</code></pre></div><h2 id="_3-4-attrs和listeners"><a href="#_3-4-attrs和listeners" class="header-anchor">#</a> 3.4 attrs和listeners</h2> <p>2.4.0 新增 这两个是不常用属性,但是高级用法很常见; 1.attrs
场景:如果父传子有很多值,那么在子组件需要定义多个 props
解决:attrs获取子传父中未在 props 定义的值</p> <div class="language- extra-class"><pre><code>// 父组件
&lt;home title=&quot;这是标题&quot; width=&quot;80&quot; height=&quot;80&quot; imgUrl=&quot;imgUrl&quot;/&gt;

// 子组件
mounted() {
  console.log(this.$attrs) //{title: &quot;这是标题&quot;, width: &quot;80&quot;, height: &quot;80&quot;, imgUrl: &quot;imgUrl&quot;}
},
</code></pre></div><p>相对应的如果子组件定义了 props,打印的值就是剔除定义的属性</p> <div class="language- extra-class"><pre><code>props: {
  width: {
    type: String,
    default: ''
  }
},
mounted() {
  console.log(this.$attrs) //{title: &quot;这是标题&quot;, height: &quot;80&quot;, imgUrl: &quot;imgUrl&quot;}
},
</code></pre></div><p>2.listeners
场景:子组件需要调用父组件的方法
解决:父组件的方法可以通过 v-on=&quot;listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用</p> <div class="language- extra-class"><pre><code>// 父组件
&lt;home @change=&quot;change&quot;/&gt;

// 子组件
mounted() {
  console.log(this.$listeners) //即可拿到 change 事件
}
</code></pre></div><p>如果是孙组件要访问父组件的属性和调用方法,直接一级一级传下去就可以</p> <p>3.inheritAttrs</p> <div class="language- extra-class"><pre><code>// 父组件
&lt;home title=&quot;这是标题&quot; width=&quot;80&quot; height=&quot;80&quot; imgUrl=&quot;imgUrl&quot;/&gt;

// 子组件
mounted() {
  console.log(this.$attrs) //{title: &quot;这是标题&quot;, width: &quot;80&quot;, height: &quot;80&quot;, imgUrl: &quot;imgUrl&quot;}
},

inheritAttrs默认值为true，true的意思是将父组件中除了props外的属性添加到子组件的根节点上(说明，即使设置为true，子组件仍然可以通过$attr获取到props意外的属性)
将inheritAttrs:false后,属性就不会显示在根节点上了
</code></pre></div><h2 id="_3-5-provide和inject"><a href="#_3-5-provide和inject" class="header-anchor">#</a> 3.5 provide和inject</h2> <p>2.2.0 新增 描述: provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中; 并且这对选项需要一起使用; 以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p> <div class="language- extra-class"><pre><code>//父组件:
provide: { //provide 是一个对象,提供一个属性或方法
  foo: '这是 foo',
  fooMethod:()=&gt;{
    console.log('父组件 fooMethod 被调用')
  }
},

// 子或者孙子组件
inject: ['foo','fooMethod'], //数组或者对象,注入到子组件
mounted() {
  this.fooMethod()
  console.log(this.foo)
}
//在父组件下面所有的子组件都可以利用inject
</code></pre></div><p>provide 和 inject 绑定并不是可响应的。这是官方刻意为之的。 然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的,对象是因为是引用类型</p> <div class="language- extra-class"><pre><code>//父组件:
provide: { 
  foo: '这是 foo'
},
mounted(){
  this.foo='这是新的 foo'
}

// 子或者孙子组件
inject: ['foo'], 
mounted() {
  console.log(this.foo) //子组件打印的还是'这是 foo'
}
</code></pre></div><h2 id="_3-6-parent和children"><a href="#_3-6-parent和children" class="header-anchor">#</a> 3.6 parent和children</h2> <p>parent:父实例children:子实例</p> <div class="language- extra-class"><pre><code>//父组件
mounted(){
  console.log(this.$children) 
  //可以拿到 一级子组件的属性和方法
  //所以就可以直接改变 data,或者调用 methods 方法
}

//子组件
mounted(){
  console.log(this.$parent) //可以拿到 parent 的属性和方法
}
</code></pre></div><p>children和parent 并不保证顺序，也不是响应式的 只能拿到一级父组件和子组件</p> <h2 id="_3-7-refs"><a href="#_3-7-refs" class="header-anchor">#</a> 3.7 $refs</h2> <div class="language- extra-class"><pre><code>// 父组件
&lt;home ref=&quot;home&quot;/&gt;

mounted(){
  console.log(this.$refs.home) //即可拿到子组件的实例,就可以直接操作 data 和 methods
}
</code></pre></div><h2 id="_3-8-root"><a href="#_3-8-root" class="header-anchor">#</a> 3.8 $root</h2> <div class="language- extra-class"><pre><code>// 父组件
mounted(){
  console.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上
  console.log(this.$root.$children[0]) //获取根实例的一级子组件
  console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件
}
</code></pre></div><h2 id="_3-9-sync"><a href="#_3-9-sync" class="header-anchor">#</a> 3.9 .sync</h2> <p>在 vue@1.x 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值; 在 vue@2.0 的由于违背单项数据流的设计被干掉了; 在 vue@2.3.0+ 以上版本又重新引入了这个 .sync 修饰符;</p> <div class="language- extra-class"><pre><code>// 父组件
&lt;home :title.sync=&quot;title&quot; /&gt;
//编译时会被扩展为
&lt;home :title=&quot;title&quot;  @update:title=&quot;val =&gt; title = val&quot;/&gt;

// 子组件
// 所以子组件可以通过$emit 触发 update 方法改变
mounted(){
  this.$emit(&quot;update:title&quot;, '这是新的title')
}
</code></pre></div><h2 id="_3-10-eventbus"><a href="#_3-10-eventbus" class="header-anchor">#</a> 3.10 EventBus</h2> <p>1.就是声明一个全局Vue实例变量 EventBus , 把所有的通信数据，事件监听都存储到这个变量上; 2.类似于 Vuex。但这种方式只适用于极小的项目 3.原理就是利用!on和emit 并实例化一个全局 vue 实现数据共享</p> <div class="language- extra-class"><pre><code>// 在 main.js
Vue.prototype.$eventBus=new Vue()

// 传值组件
this.$eventBus.$emit('eventTarget','这是eventTarget传过来的值')

// 接收组件
this.$eventBus.$on(&quot;eventTarget&quot;,v=&gt;{
  console.log('eventTarget',v);//这是eventTarget传过来的值
})
</code></pre></div><p>4.可以实现平级,嵌套组件传值,但是对应的事件名eventTarget必须是全局唯一的</p> <h2 id="_3-11-路由传参"><a href="#_3-11-路由传参" class="header-anchor">#</a> 3.11 路由传参</h2> <p>1.方案一</p> <div class="language- extra-class"><pre><code>// 路由定义
{
  path: '/describe/:id',
  name: 'Describe',
  component: Describe
}
// 页面传参
this.$router.push({
  path: `/describe/${id}`,
})
// 页面获取
this.$route.params.id
</code></pre></div><p>2.方案二</p> <div class="language- extra-class"><pre><code>// 路由定义
{
  path: '/describe',
  name: 'Describe',
  component: Describe
}
// 页面传参
this.$router.push({
  name: 'Describe',
  params: {
    id: id
  }
})
// 页面获取
this.$route.params.id
</code></pre></div><p>3.方案三</p> <div class="language- extra-class"><pre><code>// 路由定义
{
  path: '/describe',
  name: 'Describe',
  component: Describe
}
// 页面传参
this.$router.push({
  path: '/describe',
    query: {
      id: id
  `}
)
// 页面获取
this.$route.query.id
</code></pre></div><p>4.三种方案对比 方案二参数不会拼接在路由后面,页面刷新参数会丢失 方案一和三参数拼接在后面,丑,而且暴露了信息</p> <h2 id="_4-render-函数"><a href="#_4-render-函数" class="header-anchor">#</a> 4.render 函数</h2> <p>1.场景:有些代码在 template 里面写会重复很多,所以这个时候 render 函数就有作用啦</p> <div class="language- extra-class"><pre><code>// 根据 props 生成标签
// 初级
&lt;template&gt;
  &lt;div&gt;
    &lt;div v-if=&quot;level === 1&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;
    &lt;p v-else-if=&quot;level === 2&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/p&gt;
    &lt;h1 v-else-if=&quot;level === 3&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt;
    &lt;h2 v-else-if=&quot;level === 4&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt;
    &lt;strong v-else-if=&quot;level === 5&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/stong&gt;
    &lt;textarea v-else-if=&quot;level === 6&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/textarea&gt;
  &lt;/div&gt;
&lt;/template&gt;

// 优化版,利用 render 函数减小了代码重复率
&lt;template&gt;
  &lt;div&gt;
    &lt;child :level=&quot;level&quot;&gt;Hello world!&lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type='text/javascript'&gt;
  import Vue from 'vue'
  Vue.component('child', {
    render(h) {
      const tag = ['div', 'p', 'strong', 'h1', 'h2', 'textarea'][this.level-1]
      return h(tag, this.$slots.default)
    },
    props: {
      level: {  type: Number,  required: true  } 
    }
  })   
  export default {
    name: 'hehe',
    data() { return { level: 3 } }
  }
&lt;/script&gt;
</code></pre></div><p>2.render 和 template 的对比 前者适合复杂逻辑,后者适合逻辑简单; 后者属于声明是渲染，前者属于自定Render函数; 前者的性能较高，后者性能较低。</p> <h2 id="_5-异步组件"><a href="#_5-异步组件" class="header-anchor">#</a> 5.异步组件</h2> <p>场景:项目过大就会导致加载缓慢,所以异步组件实现按需加载就是必须要做的事啦 1.异步注册组件 3种方法</p> <div class="language- extra-class"><pre><code>// 工厂函数执行 resolve 回调
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包, 这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})

// 工厂函数返回 Promise
Vue.component(
  'async-webpack-example',
  // 这个 `import` 函数会返回一个 `Promise` 对象。
  () =&gt; import('./my-async-component')
)

// 工厂函数返回一个配置化组件对象
const AsyncComponent = () =&gt; ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})
</code></pre></div><p>异步组件的渲染本质上其实就是执行2次或者2次以上的渲染, 先把当前组件渲染为注释节点, 当组件加载成功后, 通过 forceRender 执行重新渲染。或者是渲染为注释节点, 然后再渲染为loading节点, 在渲染为请求完成的组件</p> <p>2.路由的按需加载</p> <div class="language- extra-class"><pre><code>webpack&lt; 2.4 时
{
  path:'/',
  name:'home',
  components:resolve=&gt;require(['@/components/home'],resolve)
}

webpack&gt; 2.4 时
{
  path:'/',
  name:'home',
  components:()=&gt;import('@/components/home')
}

import()方法由es6提出，import()方法是动态加载，返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。
</code></pre></div><h2 id="_6-动态组件"><a href="#_6-动态组件" class="header-anchor">#</a> 6.动态组件</h2> <p>场景:做一个 tab 切换时就会涉及到组件动态加载</p> <div class="language- extra-class"><pre><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
</code></pre></div><p>但是这样每次组件都会重新加载,会消耗大量性能,所以 就起到了作用</p> <div class="language- extra-class"><pre><code>&lt;keep-alive&gt;
    &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre></div><p>这样切换效果没有动画效果,这个也不用着急,可以利用内置的</p> <div class="language- extra-class"><pre><code>&lt;transition&gt;
    &lt;keep-alive&gt;
        &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
    &lt;/keep-alive&gt;
&lt;/transition&gt;
</code></pre></div><h2 id="_7-递归组件"><a href="#_7-递归组件" class="header-anchor">#</a> 7.递归组件</h2> <p>场景:如果开发一个 tree 组件,里面层级是根据后台数据决定的,这个时候就需要用到动态组件</p> <div class="language- extra-class"><pre><code>// 递归组件: 组件在它的模板内可以递归的调用自己，只要给组件设置name组件就可以了。
// 设置那么House在组件模板内就可以递归使用了,不过需要注意的是，
// 必须给一个条件来限制数量，否则会抛出错误: max stack size exceeded
// 组件递归用来开发一些具体有未知层级关系的独立组件。比如：
// 联级选择器和树形控件 

&lt;template&gt;
  &lt;div v-for=&quot;(item,index) in treeArr&quot;&gt;
      子组件，当前层级值：  &lt;br/&gt;
      &lt;!-- 递归调用自身, 后台判断是否不存在改值 --&gt;
      &lt;tree :item=&quot;item.arr&quot; v-if=&quot;item.flag&quot;&gt;&lt;/tree&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  // 必须定义name，组件内部才能递归调用
  name: 'tree',
  data(){
    return {}
  },
  // 接收外部传入的值
  props: {
     item: {
      type:Array,
      default: ()=&gt;[]
    }
  }
}
&lt;/script&gt;
</code></pre></div><p>递归组件必须设置name 和结束的阀值</p> <h2 id="_8-函数式组件"><a href="#_8-函数式组件" class="header-anchor">#</a> 8.函数式组件</h2> <p>定义:无状态,无法实例化，内部没有任何生命周期处理方法 规则:在 2.3.0 之前的版本中，如果一个函数式组件想要接收 prop，则 props 选项是必须的。 在 2.3.0 或以上的版本中，你可以省略 props 选项，所有组件上的特性都会被自动隐式解析为 prop 在 2.5.0 及以上版本中，如果你使用了单文件组件(就是普通的.vue 文件),可以直接在 template 上声明functional 组件需要的一切都是通过 context 参数传递</p> <p>context 属性有: 1.props：提供所有 prop 的对象 2.children: VNode 子节点的数组 3.slots: 一个函数，返回了包含所有插槽的对象 4.scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。 5.data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件 6.parent：对父组件的引用 7.listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。 8.injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性</p> <div class="language- extra-class"><pre><code>&lt;template functional&gt;
  &lt;div v-for=&quot;(item,index) in props.arr&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
</code></pre></div><h2 id="_9-components和-vue-component"><a href="#_9-components和-vue-component" class="header-anchor">#</a> 9.components和 Vue.component</h2> <p>components:局部注册组件</p> <div class="language- extra-class"><pre><code>export default{
  components:{home}
}
</code></pre></div><p>Vue.component:全局注册组件</p> <div class="language- extra-class"><pre><code>Vue.component('home',home)
</code></pre></div><h2 id="_10-vue-extend"><a href="#_10-vue-extend" class="header-anchor">#</a> 10.Vue.extend</h2> <p>场景:vue 组件中有些需要将一些元素挂载到元素上,这个时候 extend 就起到作用了 是构造一个组件的语法器 写法:</p> <div class="language- extra-class"><pre><code>// 创建构造器
var Profile = Vue.extend({
  template: '&lt;p&gt;&lt;/br&gt;实例传入的数据为:&lt;/p&gt;',//template对应的标签最外层必须只有一个标签
  data: function () {
    return {
      extendData: '这是extend扩展的数据',
    }
  },
  props:['propsExtend']
})

// 创建的构造器可以挂载到元素上,也可以通过 components 或 Vue.component()注册使用
// 挂载到一个元素上。可以通过propsData传参.
new Profile({propsData:{propsExtend:'我是实例传入的数据'}}).$mount('#app-extend')

// 通过 components 或 Vue.component()注册
Vue.component('Profile',Profile)
</code></pre></div><h2 id="_11-mixins"><a href="#_11-mixins" class="header-anchor">#</a> 11.mixins</h2> <p>场景:有些组件有些重复的 js 逻辑,如校验手机验证码,解析时间等,mixins 就可以实现这种混入 mixins 值是一个数组</p> <div class="language- extra-class"><pre><code>const mixin={
    created(){
      this.dealTime()
    },
    methods:{
      dealTime(){
        console.log('这是mixin的dealTime里面的方法');
      }
  }
}

export default{
  mixins:[mixin]
}
</code></pre></div><h2 id="_12-extends"><a href="#_12-extends" class="header-anchor">#</a> 12.extends</h2> <p>extends用法和mixins很相似,只不过接收的参数是简单的选项对象或构造函数,所以extends只能单次扩展一个组件</p> <div class="language- extra-class"><pre><code>const extend={
    created(){
      this.dealTime()
    },
    methods:{
      dealTime(){
        console.log('这是mixin的dealTime里面的方法');
      }
  }
}

export default{
  extends:extend
}
</code></pre></div><h2 id="_13-vue-use"><a href="#_13-vue-use" class="header-anchor">#</a> 13.Vue.use()</h2> <p>场景:我们使用 element时会先 import,再 Vue.use()一下,实际上就是注册组件,触发 install 方法; 这个在组件调用会经常使用到; 会自动组织多次注册相同的插件.</p> <h2 id="_14-install"><a href="#_14-install" class="header-anchor">#</a> 14.install</h2> <p>场景:在 Vue.use()说到,执行该方法会触发 install 是开发vue的插件,这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象(可选)</p> <div class="language- extra-class"><pre><code>var MyPlugin = {};
  MyPlugin.install = function (Vue, options) {
    // 2. 添加全局资源,第二个参数传一个值默认是update对应的值
    Vue.directive('click', {
      bind(el, binding, vnode, oldVnode) {
        //做绑定的准备工作,添加时间监听
        console.log('指令my-directive的bind执行啦');
      },
      inserted: function(el){
      //获取绑定的元素
      console.log('指令my-directive的inserted执行啦');
      },
      update: function(){
      //根据获得的新值执行对应的更新
      //对于初始值也会调用一次
      console.log('指令my-directive的update执行啦');
      },
      componentUpdated: function(){
      console.log('指令my-directive的componentUpdated执行啦');
      },
      unbind: function(){
      //做清理操作
      //比如移除bind时绑定的事件监听器
      console.log('指令my-directive的unbind执行啦');
      }
    })

    // 3. 注入组件
    Vue.mixin({
      created: function () {
        console.log('注入组件的created被调用啦');
        console.log('options的值为',options)
      }
    })

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function (methodOptions) {
      console.log('实例方法myMethod被调用啦');
    }
  }

  //调用MyPlugin
  Vue.use(MyPlugin,{someOption: true })

  //3.挂载
  new Vue({
    el: '#app'
  });
</code></pre></div><p>更多请戳 vue中extend，mixins，extends，components,install的几个操作</p> <h2 id="_15-vue-nexttick"><a href="#_15-vue-nexttick" class="header-anchor">#</a> 15.Vue.nextTick</h2> <p>2.1.0 新增 场景:页面加载时需要让文本框获取焦点 用法:在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p> <div class="language- extra-class"><pre><code>mounted(){ //因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick
  this.$nextTick(() =&gt; {
    this.$refs.inputs.focus() //通过 $refs 获取dom 并绑定 focus 方法
  })
}
</code></pre></div><h2 id="_16-vue-directive"><a href="#_16-vue-directive" class="header-anchor">#</a> 16.Vue.directive</h2> <p>16.1 使用场景:
官方给我们提供了很多指令,但是我们如果想将文字变成指定的颜色定义成指令使用,这个时候就需要用到Vue.directive</p> <div class="language- extra-class"><pre><code>// 全局定义
Vue.directive(&quot;change-color&quot;,function(el,binding,vnode){
  el.style[&quot;color&quot;]= binding.value;
})

// 使用
&lt;template&gt;
&lt;div v-change-color=“color”&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default{
    data(){
      return{
        color:'green'
      }
    }
  }
&lt;/script&gt;
</code></pre></div><p>16.2 生命周期
1.bind 只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。 2.inserted:被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中) 3.update: 被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新 4.componentUpdate :被绑定的元素所在模板完成一次更新更新周期的时候调用 5.unbind: 只调用一次，指令月元素解绑的时候调用</p> <h2 id="_17-vue-filter"><a href="#_17-vue-filter" class="header-anchor">#</a> 17.Vue.filter</h2> <p>场景:时间戳转化成年月日这是一个公共方法,所以可以抽离成过滤器使用</p> <div class="language- extra-class"><pre><code>// 使用
// 在双花括号中


// 在 `v-bind` 中
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;

// 全局注册
Vue.filter('stampToYYMMDD', (value) =&gt;{
  // 处理逻辑
})

// 局部注册
filters: {
  stampToYYMMDD: (value)=&gt; {
    // 处理逻辑
  }
}

// 多个过滤器全局注册
// /src/common/filters.js
let dateServer = value =&gt; value.replace(/(\d{4})(\d{2})(\d{2})/g, '$1-$2-$3') 
export { dateServer }
// /src/main.js
import * as custom from './common/filters/custom'
Object.keys(custom).forEach(key =&gt; Vue.filter(key, custom[key]))
</code></pre></div><h2 id="_18-vue-compile"><a href="#_18-vue-compile" class="header-anchor">#</a> 18.Vue.compile</h2> <p>场景:在 render 函数中编译模板字符串。只在独立构建时有效</p> <div class="language- extra-class"><pre><code>var res = Vue.compile('&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;')

new Vue({
  data: {
    msg: 'hello'
  },
  render: res.render,
  staticRenderFns: res.staticRenderFns
})
</code></pre></div><h2 id="_19-vue-version"><a href="#_19-vue-version" class="header-anchor">#</a> 19.Vue.version</h2> <p>场景:有些开发插件需要针对不同 vue 版本做兼容,所以就会用到 Vue.version 用法:Vue.version()可以获取 vue 版本</p> <div class="language- extra-class"><pre><code>var version = Number(Vue.version.split('.')[0])

if (version === 2) {
  // Vue v2.x.x
} else if (version === 1) {
  // Vue v1.x.x
} else {
  // Unsupported versions of Vue
}
</code></pre></div><h2 id="_20-vue-set"><a href="#_20-vue-set" class="header-anchor">#</a> 20.Vue.set()</h2> <p>场景:当你利用索引直接设置一个数组项时或你修改数组的长度时,由于 Object.defineprototype()方法限制,数据不响应式更新 不过vue.3.x 将利用 proxy 这个问题将得到解决 解决方案:</p> <div class="language- extra-class"><pre><code>// 利用 set
this.$set(arr,index,item)

// 利用数组 push(),splice()   
</code></pre></div><h2 id="_21-vue-config-keycodes"><a href="#_21-vue-config-keycodes" class="header-anchor">#</a> 21.Vue.config.keyCodes</h2> <p>场景:自定义按键修饰符别名</p> <div class="language- extra-class"><pre><code>// 将键码为 113 定义为 f2
Vue.config.keyCodes.f2 = 113;
&lt;input type=&quot;text&quot; @keyup.f2=&quot;add&quot;/&gt;
</code></pre></div><h2 id="_22-vue-config-performance"><a href="#_22-vue-config-performance" class="header-anchor">#</a> 22.Vue.config.performance</h2> <p>场景:监听性能</p> <div class="language- extra-class"><pre><code>Vue.config.performance = true
</code></pre></div><p>只适用于开发模式和支持 performance.mark API 的浏览器上</p> <h2 id="_23-vue-config-errorhandler"><a href="#_23-vue-config-errorhandler" class="header-anchor">#</a> 23.Vue.config.errorHandler</h2> <p>1.场景:指定组件的渲染和观察期间未捕获错误的处理函数 2.规则: 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了 从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理 3.使用</p> <div class="language- extra-class"><pre><code>Vue.config.errorHandler = function (err, vm, info) {
  // handle error
  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
  // 只在 2.2.0+ 可用
}
</code></pre></div><h2 id="_24-vue-config-warnhandler"><a href="#_24-vue-config-warnhandler" class="header-anchor">#</a> 24.Vue.config.warnHandler</h2> <p>2.4.0 新增 1.场景:为 Vue 的运行时警告赋予一个自定义处理函数,只会在开发者环境下生效 2.用法:</p> <div class="language- extra-class"><pre><code>Vue.config.warnHandler = function (msg, vm, trace) {
  // `trace` 是组件的继承关系追踪
}
</code></pre></div><h2 id="_25-v-once"><a href="#_25-v-once" class="header-anchor">#</a> 25.v-once</h2> <p>场景:有些 template 中的静态 dom 没有改变,这时就只需要渲染一次,可以降低性能开销</p> <div class="language- extra-class"><pre><code>&lt;span v-once&gt; 这时只需要加载一次的标签&lt;/span&gt;
</code></pre></div><p>v-once 和 v-pre 的区别: v-once只渲染一次；v-pre不编译,原样输出</p> <h2 id="_26-事件修饰符"><a href="#_26-事件修饰符" class="header-anchor">#</a> 26.事件修饰符</h2> <div class="language- extra-class"><pre><code>.stop:阻止冒泡
.prevent:阻止默认行为
.self:仅绑定元素自身触发
.once: 2.1.4 新增,只触发一次
.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用
</code></pre></div><h2 id="_27-按键修饰符和按键码"><a href="#_27-按键修饰符和按键码" class="header-anchor">#</a> 27.按键修饰符和按键码</h2> <p>场景:有的时候需要监听键盘的行为,如按下 enter 去查询接口等</p> <div class="language- extra-class"><pre><code>// 对应键盘上的关键字
.enter
.tab
.delete (捕获“删除”和“退格”键)
.esc
.space
.up
.down
.left
.right
</code></pre></div><h2 id="_28-vue-router"><a href="#_28-vue-router" class="header-anchor">#</a> 28.Vue-router</h2> <p>场景:Vue-router 是官方提供的路由插件</p> <h2 id="_29-object-freeze"><a href="#_29-object-freeze" class="header-anchor">#</a> 29.Object.freeze</h2> <p>场景:一个长列表数据,一般不会更改,但是vue会做getter和setter的转换 用法:是ES5新增的特性，可以冻结一个对象，防止对象被修改 支持:vue 1.0.18+对其提供了支持，对于data或vuex里使用freeze冻结了的对象，vue不会做getter和setter的转换 注意:冻结只是冻结里面的单个属性,引用地址还是可以更改</p> <div class="language- extra-class"><pre><code>new Vue({
    data: {
        // vue不会对list里的object做getter、setter绑定
        list: Object.freeze([
            { value: 1 },
            { value: 2 }
        ])
    },
    mounted () {
        // 界面不会有响应,因为单个属性被冻结
        this.list[0].value = 100;

        // 下面两种做法，界面都会响应
        this.list = [
            { value: 100 },
            { value: 200 }
        ];
        this.list = Object.freeze([
            { value: 100 },
            { value: 200 }
        ]);
    }
})
</code></pre></div><h2 id="_30-为路径设置别名"><a href="#_30-为路径设置别名" class="header-anchor">#</a> 30.为路径设置别名</h2> <p>1.场景:在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名</p> <p>2.vue-cli 2.x 配置</p> <div class="language- extra-class"><pre><code>// 在 webpack.base.config.js中的 resolve 配置项，在其 alias 中增加别名
resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
    }
  },
</code></pre></div><p>3.vue-cli 3.x 配置</p> <div class="language- extra-class"><pre><code>// 在根目录下创建vue.config.js
var path = require('path')
function resolve (dir) {
  console.log(__dirname)
  return path.join(__dirname, dir)
}
module.exports = {
  chainWebpack: config =&gt; {
    config.resolve.alias
      .set(key, value) // key,value自行定义，比如.set('@@', resolve('src/components'))
  }
}</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/es6/" class="prev">
        es6
      </a></span> <span class="next"><a href="/blog/react/">
        react
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a660b788.js" defer></script><script src="/assets/js/2.efd5ddf9.js" defer></script><script src="/assets/js/12.4b34605b.js" defer></script>
  </body>
</html>
