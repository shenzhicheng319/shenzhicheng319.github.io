(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{317:function(n,e,t){"use strict";t.r(e);var a=t(318),v=t.n(a);for(var s in a)"default"!==s&&function(n){t.d(e,n,(function(){return a[n]}))}(s);e.default=v.a},318:function(n,e){},351:function(n,e,t){"use strict";t.d(e,"a",(function(){return a})),t.d(e,"b",(function(){return v}));var a=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[n._v("#")]),n._v(" es6")]),n._v(" "),t("p",[n._v("ES6总结篇（一）")]),n._v(" "),t("h1",{attrs:{id:"第一章、eacmscript-6-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一章、eacmscript-6-简介"}},[n._v("#")]),n._v(" 第一章、EACMScript 6 简介")]),n._v(" "),t("h2",{attrs:{id:"_1-eacmscript与javascript的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-eacmscript与javascript的关系"}},[n._v("#")]),n._v(" 1. EACMScript与JavaScript的关系")]),n._v(" "),t("p",[n._v("大家对JavaScript起源都有一定了解，这个就不再赘述，直接引用ES6的总结：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。\n另外的 ECMAScript 方言还有 JScript 和ActionScript。日常场合，这两个词是可以互换的。\n")])])]),t("h2",{attrs:{id:"_2-babel-转码器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-babel-转码器"}},[n._v("#")]),n._v(" 2. Babel 转码器")]),n._v(" "),t("ol",[t("li",[t("strong",[n._v("Babel的作用")])])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("1.1 "),t("strong",[n._v("Babel")]),n._v(" babeljs.io/ 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行")]),n._v(" "),t("p",[n._v("// 转码前\ninput.map(item => item + 1);")]),n._v(" "),t("p",[n._v("// 转码后\ninput.map(function (item) {\nreturn item + 1;\n});")])])]),n._v(" "),t("p",[n._v("由于ES6有兼容性问题，导致有些语法糖不能在某些浏览器上正确执行，经过"),t("strong",[n._v("Babel")]),n._v("转码之后变成大家都兼容的ES5，就可以正常执行了。")]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[n._v("安装以及配置")])])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("2.2.1 在项目的命令行安装 "),t("code",[n._v("$ npm install --save-dev @babel/core")])])]),n._v(" "),t("li",[t("p",[n._v("2.2.2 "),t("strong",[n._v(".babelrc文件")]),n._v("用来设置转码规则和插件，基本规格如下：")]),n._v(" "),t("p",[n._v('{\n"presets": [\n"@babel/env", //最新转码规则\n"@babel/preset-react" //react 转码规则\n],\n"plugins": []\n}')])])]),n._v(" "),t("p",[n._v("presets字段设定转码规则： 官方提供以下的规则集(需要先安装再在**.babelrc文件**中使用，安装如下)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("# 最新转码规则\n$ npm install --save-dev @babel/preset-env\n# react 转码规则\n$ npm install --save-dev @babel/preset-reac\n")])])]),t("p",[t("strong",[n._v("注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。")])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("2.2.3 "),t("strong",[n._v("命令行工具@babel/cli、@babel/node、@babel/register")]),n._v(" 它的安装命令如下：")]),n._v(" "),t("p",[n._v("$ npm install --save-dev @babel/cli\n$ npm install --save-dev @babel/node #提供一个支持 ES6 的 REPL 环境\n$ npm install --save-dev @babel/register\n#改写require命令，为它加上一个钩子。\n#每当使用require加载.js、.jsx、.es和.es6\n#后缀名的文件，就会先用 Babel 进行转码")])])]),n._v(" "),t("p",[n._v("@babel/cli 基本用法（"),t("strong",[n._v("babel指令")]),n._v("）：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("# 转码结果输出到标准输出\n$ npx babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ npx babel example.js --out-file compiled.js\n# 或者\n$ npx babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ npx babel src --out-dir lib\n# 或者\n$ npx babel src -d lib\n\n# -s 参数生成source map文件\n$ npx babel src -d lib -s\n")])])]),t("p",[n._v("@babel/node 基本用法（"),t("strong",[n._v("babel-node指令")]),n._v("）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("$ npx babel-node\n> (x => x * 2)(1)\n2\n")])])]),t("p",[n._v("@babel/register 基本用法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("//使用时必须首先加载@babel/register\nrequire('@babel/register');\nrequire('./es6.js');\n")])])]),t("ul",[t("li",[t("p",[n._v("2.2.4 polyfill （用来转换babel无法转换的API以及一些语法） 使用core-js和"),t("strong",[n._v("regenerator-runtime(提供generator函数的转码)")]),n._v("。")])]),n._v(" "),t("li",[t("p",[n._v("安装："),t("code",[n._v("$ npm install --save-dev core-js regenerator-runtime")])])]),n._v(" "),t("li",[t("p",[n._v("使用")]),n._v(" "),t("p",[n._v("import 'core-js';\nimport 'regenerator-runtime/runtime';\n// 或者\nrequire('core-js');\nrequire('regenerator-runtime/runtime);")])])]),n._v(" "),t("p",[n._v("Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的"),t("a",{attrs:{href:"definitions.js"}},[n._v("github.com/babel/babel…")]),n._v("文件")]),n._v(" "),t("ul",[t("li",[t("p",[t("strong",[n._v("浏览器环境")])])]),n._v(" "),t("li",[t("p",[n._v("Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。")])])]),n._v(" "),t("p",[n._v("注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。")]),n._v(" "),t("p",[n._v("Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。")]),n._v(" "),t("h1",{attrs:{id:"第二章、let-和-const-命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二章、let-和-const-命令"}},[n._v("#")]),n._v(" 第二章、let 和 const 命令")]),n._v(" "),t("h2",{attrs:{id:"_1-let-的特性以及用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-let-的特性以及用法"}},[n._v("#")]),n._v(" 1. let 的特性以及用法")]),n._v(" "),t("ol",[t("li",[n._v("首先，我先总结一下"),t("strong",[n._v("var")]),n._v("缺点")])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("1.1 允许重复的变量声明：导致数据被覆盖")])]),n._v(" "),t("li",[t("p",[n._v("1.2 变量提升：怪异的数据访问、闭包问题")])]),n._v(" "),t("li",[t("p",[n._v("1.3 全局变量挂载到全局对象：全局对象成员污染问题")]),n._v(" "),t("p",[n._v("// 1. 允许重复的变量声明：导致数据被覆盖\nvar a = 1;\nfunction print(){\nconsole.log(a)\n}\n// 假设这里有一千行代码\nvar a = 2;\nprint(); // 2")]),n._v(" "),t("p",[n._v("// 2. 变量提升：怪异的数据访问")]),n._v(" "),t("p",[n._v('if (Math.random() < 0.5) {\nvar a = "abc";\nconsole.log(a);\n}\nelse {\nconsole.log(a);\n}\nconsole.log(a); // 无论怎样访问都是abc')]),n._v(" "),t("p",[n._v("// 3. 全局变量挂载到全局对象：全局对象成员污染问题")]),n._v(" "),t("p",[n._v('var abc = "123";\nconsole.log(window.abc); // 123')]),n._v(" "),t("p",[n._v('// var console = "abc";\n// console.log(console) // abc 这个很可怕')])])]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[n._v("let (完美的解决了这些问题)\n"),t("ol",[t("li",[n._v("let声明的变量不会挂载到全局对象")]),n._v(" "),t("li",[n._v("let声明的变量，不允许当前作用域范围内重复声明")]),n._v(" "),t("li",[n._v("使用let不会有变量提升，因此，不能在定义let变量之前使用它(形成暂时性死区)")])])])]),n._v(" "),t("ul",[t("li",[t("p",[t("strong",[n._v("暂时性死区")]),n._v("：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。")])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("块级作用域")]),n._v("：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域")]),n._v(" "),t("p",[n._v("// 1. let声明的变量不会挂载到全局对象")]),n._v(" "),t("p",[n._v("let a = 123;\nconsole.log(window.a) // undefined")]),n._v(" "),t("p",[n._v("// 2. let声明的变量，不允许当前作用域范围内重复声明")]),n._v(" "),t("p",[n._v("if (Math.random() < 0.5) {\nlet a = 123; //定义在当前块级作用域\nconsole.log(a) //当前块级作用域中的a\n} else {\n//这是另外一个块级作用域，该作用域中找不到a\nconsole.log(a)\n}")]),n._v(" "),t("p",[n._v("//3. 使用let不会有变量提升，因此，不能在定义let变量之前使用它")]),n._v(" "),t("p",[n._v("console(c); // Uncaught ReferenceError: c is not defined 形成了暂时性死区\nlet c = 6;")])])]),n._v(" "),t("p",[t("strong",[n._v("暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。")])]),n._v(" "),t("h2",{attrs:{id:"_2-const-特性以及方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-const-特性以及方法"}},[n._v("#")]),n._v(" 2. const 特性以及方法")]),n._v(" "),t("ul",[t("li",[n._v("const和let完全相同，仅在于用const声明的变量，必须在声明时赋值，而且不可以重新赋值。（这里就不再举例其使用了）")]),n._v(" "),t("li",[n._v("实际上，在开发中，应该尽量使用const来声明变量，以保证变量的值不会随意篡改，原因：")])]),n._v(" "),t("ol",[t("li",[n._v("根据经验，开发中的很多变量，都是不会更改，也不应该更改的。")]),n._v(" "),t("li",[n._v("后续的很多框架或者是第三方JS库，都要求数据不可变，使用常量可以一定程度上保证这一点。")])]),n._v(" "),t("p",[t("strong",[n._v("注意")])]),n._v(" "),t("ol",[t("li",[t("p",[n._v("常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变")])]),n._v(" "),t("li",[t("p",[n._v("常量的命名")]),n._v(" "),t("ol",[t("li",[n._v("特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率、月地距地或其他一些绝不可能变化的配置。通常，"),t("strong",[n._v("该常量的名称全部使用大写，多个单词之间用下划线分割")])]),n._v(" "),t("li",[n._v("普通的常量：使用和之前一样的命名即可")])])]),n._v(" "),t("li",[t("p",[n._v("在for循环中，循环变量不可以使用常量，只能用let 关于主义的第一点，我举个例子")]),n._v(" "),t("p",[n._v('const a = {\nname: "kevin",\nage: 123\n};\na.name = "abc";\nconsole.log(a) // abc')]),n._v(" "),t("p",[n._v("// const PI = 3.14;\n// const MOON_EARTH_DISTANCE = 3245563424; //月地距离")])])]),n._v(" "),t("h2",{attrs:{id:"_3-顶层对象属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-顶层对象属性"}},[n._v("#")]),n._v(" 3. 顶层对象属性")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象")]),n._v(" "),t("p",[n._v("var a = 1;\n// 如果在 Node 的 REPL 环境，可以写成 global.a\n// 或者采用通用方法，写成 this.a\nwindow.a // 1")]),n._v(" "),t("p",[n._v("let b = 1;\nwindow.b // undefined let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性")])]),n._v(" "),t("li",[t("p",[n._v("globalThis 对象 因为环境的不同，顶层对象在各种实现里面是不统一的")]),n._v(" "),t("ol",[t("li",[n._v("浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。")]),n._v(" "),t("li",[n._v("浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。")]),n._v(" "),t("li",[n._v("Node 里面，顶层对象是global，但其他环境都不支持。 在不同环境中获取顶层对象的this ES6 提供了两个方法")])]),n._v(" "),t("p",[n._v("// 方法一\n(typeof window !== 'undefined'\n? window\n: (typeof process === 'object' &&\ntypeof require === 'function' &&\ntypeof global === 'object')\n? global\n: this);")]),n._v(" "),t("p",[n._v("// 方法二\nvar getGlobal = function () {\nif (typeof self !== 'undefined') { return self; }\nif (typeof window !== 'undefined') { return window; }\nif (typeof global !== 'undefined') { return global; }\nthrow new Error('unable to locate global object');\n};")])])]),n._v(" "),t("p",[n._v("而且，ES6最后提到：")]),n._v(" "),t("ul",[t("li",[n._v("ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。")]),n._v(" "),t("li",[n._v("垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。")])]),n._v(" "),t("h1",{attrs:{id:"第三章、变量的解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三章、变量的解构赋值"}},[n._v("#")]),n._v(" 第三章、变量的解构赋值")]),n._v(" "),t("ul",[t("li",[n._v("在此，我这里主要介绍工作中我们常用的几种解构赋值：")])]),n._v(" "),t("ol",[t("li",[n._v("对象的解构")]),n._v(" "),t("li",[n._v("数组的解构")]),n._v(" "),t("li",[n._v("参数的解构")]),n._v(" "),t("li",[n._v("其他的解构")])]),n._v(" "),t("h2",{attrs:{id:"_1-对象的解构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-对象的解构"}},[n._v("#")]),n._v(" 1. 对象的解构")]),n._v(" "),t("p",[t("strong",[n._v("1. 什么是解构")])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） "),t("strong",[n._v("解构不会对被解构的目标造成任何影响")])])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("在解构中使用默认值")])]),n._v(" "),t("p",[n._v('{同名变量 = 默认值}\nconst user = {\nname: "kevin",\nage: 11,\nsex: "男",\naddress: {\nprovince: "四川",\ncity: "成都"\n}\n}\n//解构出user中的name、province\n//定义两个变量name、province\n//再解构\nconst { name, address: { province } } = user;\nconsole.log(name, province)\n// name: kevin  province: 四川')])]),n._v(" "),t("li",[t("p",[t("strong",[n._v("非同名属性解构")])]),n._v(" "),t("p",[n._v("{属性名:变量名}\nlet obj = {};\nlet arr = [];\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\nobj // {prop:123}\narr // [true]\n//如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错")]),n._v(" "),t("p",[n._v("let {foo: {bar}} = {baz: 'baz'};\n// 报错")])])]),n._v(" "),t("h2",{attrs:{id:"_2-数组的解构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-数组的解构"}},[n._v("#")]),n._v(" 2. 数组的解构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("let [a, b, c] = [1, 2, 3];\n// a:1 b:2 c:3\n")])])]),t("p",[n._v("这种写法属于"),t("strong",[n._v("模式匹配")]),n._v("，只要等号两边的模式相同，左边的变量就会被赋予对应的值")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("下面一些使用嵌套数组进行解构的例子以及一些情况")]),n._v(" "),t("p",[n._v("let [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1    bar // 2    baz // 3")]),n._v(" "),t("p",[n._v('let [ , , third] = ["foo", "bar", "baz"];\nthird // "baz"')]),n._v(" "),t("p",[n._v("// 1. 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\nlet [x, y] = [1, 2, 3];\nx // 1  y // 2")]),n._v(" "),t("p",[n._v("let [a, [b], d] = [1, [2, 3], 4];\na // 1  b // 2  d // 4\n// 2. 数组解构出 值和数组（运用扩展运算符... 在接下来的章节里会就介绍到）")]),n._v(" "),t("p",[n._v("let [head, ...tail] = [1, 2, 3, 4];\nhead // 1   tail // [2, 3, 4]")]),n._v(" "),t("p",[n._v("// 3. 如果解构不成功，变量的值就等于undefined。")]),n._v(" "),t("p",[n._v("let [x, y, ...z] = ['a'];\nx // \"a\"    y // undefined  z // []")]),n._v(" "),t("p",[n._v("// 4. 如果等号的右边不是数组（或者严格地说，不是可遍历的解构，参见《Iterator》一章），那么将会报错。")]),n._v(" "),t("p",[n._v("// 4.1 要么转为对象以后不具备 Iterator 接口")]),n._v(" "),t("p",[n._v("let [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;")]),n._v(" "),t("p",[n._v("// 4.2 本身就不具备 Iterator 接口")]),n._v(" "),t("p",[n._v("let [foo] = {};")])])]),n._v(" "),t("p",[n._v("从最后的例子可以看出，只要某种数据解构具有 Iterator 接口，都可以采用数组形式的解构赋值。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("function* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n")])])]),t("p",[n._v("上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。")]),n._v(" "),t("h2",{attrs:{id:"_3-参数的解构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-参数的解构"}},[n._v("#")]),n._v(" 3. 参数的解构")]),n._v(" "),t("p",[n._v("废话不多说，直接上例子")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("function add([x, y]){\n  return x + y;\n}\nadd([1, 2]); // 3\n// 函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。\n// 对于函数内部的代码来说，它们能感受到的参数就是x和y。\n")])])]),t("p",[n._v("箭头函数也可以解构赋值")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [ 3, 7 ]\n")])])]),t("p",[n._v("函数参数的解构也可以使用"),t("strong",[n._v("默认值")]),n._v(" 在第五章会给出介绍")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("function move({x = 0, y = 0} = {}) { //x y 在参数上设置默认值\n  return [x, y];\n}\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n// 函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。\n// 如果解构失败，x和y等于默认值。\n")])])]),t("p",[n._v("undefined就会触发函数参数的默认值。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("[1, undefined, 3].map((x = 'yes') => x);\n// [ 1, 'yes', 3 ]\n")])])]),t("h2",{attrs:{id:"_4-其他的解构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-其他的解构"}},[n._v("#")]),n._v(" 4. 其他的解构")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("对象的解构也可以指定默认值 设置"),t("strong",[n._v("默认值")])]),n._v(" "),t("p",[n._v("var {x = 3} = {};\nx // 3")]),n._v(" "),t("p",[n._v("var {x, y = 5} = {x: 1};\nx // 1\ny // 5")]),n._v(" "),t("p",[n._v("var {x: y = 3} = {};\ny // 3")]),n._v(" "),t("p",[n._v("var {x: y = 3} = {x: 5};\ny // 5")]),n._v(" "),t("p",[n._v("var { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"")])])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("默认值生效的条件是，对象的属性值严格等于undefined。")]),n._v(" "),t("p",[n._v("var {x = 3} = {x: undefined};\nx // 3")]),n._v(" "),t("p",[n._v("var {x = 3} = {x: null};\nx // null  因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效")])])]),n._v(" "),t("p",[t("strong",[n._v("注意点")])]),n._v(" "),t("ol",[t("li",[t("p",[n._v("如果要将一个已经声明的变量用于解构赋值，必须非常小心。")]),n._v(" "),t("p",[n._v("// 错误的写法\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。\n// 只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。\n// 正确的写法\nlet x;\n({x} = {x: 1});")])]),n._v(" "),t("li",[t("p",[n._v("解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式")]),n._v(" "),t("p",[n._v("({} = [true, false]);\n({} = 'abc');\n({} = []);")])]),n._v(" "),t("li",[t("p",[n._v("由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。")]),n._v(" "),t("p",[n._v("let arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3")])])]),n._v(" "),t("h1",{attrs:{id:"第四章、字符串的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第四章、字符串的扩展"}},[n._v("#")]),n._v(" 第四章、字符串的扩展")]),n._v(" "),t("h2",{attrs:{id:"_1-更好的unicode支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-更好的unicode支持"}},[n._v("#")]),n._v(" 1. 更好的Unicode支持")]),n._v(" "),t("p",[n._v("首先，介绍一下码元：")]),n._v(" "),t("ol",[t("li",[n._v("早期，由于存储空间宝贵，Unicode使用16位二进制来存储文字。我们将一个16位的二进制编码叫做一个"),t("strong",[n._v("码元（Code Unit）")]),n._v("。后来，由于技术的发展，Unicode对文字编码进行了扩展，将某些文字扩展到了32位（占用两个码元），并且，将某个文字对应的二进制数字叫做"),t("strong",[n._v("码点（Code Point）")]),n._v("。")])]),n._v(" "),t("p",[n._v("ES6为了解决这个困扰，为字符串提供了方法：codePointAt，根据字符串码元的位置得到其码点。")]),n._v(" "),t("p",[n._v("同时，ES6为正则表达式添加了一个flag: u，如果添加了该配置，则匹配时，使用码点匹配")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('const text = "𠮷"; //占用了两个码元（32位）\n\nconsole.log("字符串长度：", text.length); // 2\nconsole.log("使用正则测试：", /^.$/u.test(text)); // true\nconsole.log("得到第一个码元：", text.charCodeAt(0)); // 55362\nconsole.log("得到第二个码元：", text.charCodeAt(1)); // 57271\n\n//𠮷：\\ud842\\udfb7\nconsole.log("得到第一个码点：", text.codePointAt(0)); // 134071\nconsole.log("得到第二个码点：", text.codePointAt(1)); // 57271\n')])])]),t("p",[n._v("然后我们完成一个自己的"),t("strong",[n._v("判断字符串char，是32位，还是16位")]),n._v("方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("function is32bit(char, i) {\n    //如果码点大于了16位二进制的最大值，则其是32位的\n    return char.codePointAt(i) > 0xffff;\n}\n")])])]),t("p",[n._v("得到一个字符串码点的真实长度")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('function getLengthOfCodePoint(str) {\n    var len = 0;\n    for (let i = 0; i < str.length; i++) {\n        //i在索引码元\n        if (is32bit(str, i)) {\n            //当前字符串，在i这个位置，占用了两个码元\n            i++;\n        }\n        len++;\n    }\n    return len;\n}\n\nconsole.log("𠮷是否是32位的：", is32bit("𠮷", 0)) // 𠮷是否是32位的： true\nconsole.log("ab𠮷ab的码点长度：", getLengthOfCodePoint("ab𠮷ab")) // ab𠮷ab的码点长度： 5\n')])])]),t("h2",{attrs:{id:"_2-增加的字符串api-只举出工作中常用的四种"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-增加的字符串api-只举出工作中常用的四种"}},[n._v("#")]),n._v(" 2. 增加的字符串API(只举出工作中常用的四种)")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("includes 判断字符串中是否包含指定的子字符串")])]),n._v(" "),t("li",[t("p",[n._v("startsWith 判断字符串中是否以指定的字符串开始")])]),n._v(" "),t("li",[t("p",[n._v("endsWith 判断字符串中是否以指定的字符串结尾")])]),n._v(" "),t("li",[t("p",[n._v("repeat 将字符串重复指定的次数，然后返回一个新字符串")]),n._v(" "),t("p",[n._v('const text = "我真是狠人";')]),n._v(" "),t("p",[n._v('console.log("是否包含“狠”：", text.includes("狠"));\nconsole.log("是否以“我”开头：", text.startsWith("我"));\nconsole.log("是否以“狠人”结尾：",')]),n._v(" "),t("p",[n._v('text.endsWith("狠人"));\nconsole.log("重复4次：", text.repeat(4));\n// 由于过于简单，就不把console结果展示啦，有兴趣的可以直接试一下，哈哈哈')])])]),n._v(" "),t("h2",{attrs:{id:"_3-模板字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-模板字符串"}},[n._v("#")]),n._v(" 3. 模板字符串")]),n._v(" "),t("p",[t("strong",[n._v("模板字符串是此章节的灵魂")])]),n._v(" "),t("ul",[t("li",[n._v("ES6之前处理字符串繁琐的两个方面：")])]),n._v(" "),t("ol",[t("li",[n._v("多行字符串")]),n._v(" "),t("li",[n._v("字符串拼接")])]),n._v(" "),t("ul",[t("li",[n._v("在ES6中，提供了模板字符串的书写，可以非常方便的换行和拼接，要做的，仅仅是将字符串的开始或结尾改为 ` 符号")])]),n._v(" "),t("p",[n._v("如果要在字符串中拼接js表达式，只需要在模板字符串中使用"),t("code",[n._v("${JS表达式}")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('var love1 = "秋葵";\nvar love2 = "香菜";\n\nvar text = `A喜欢${love1}\nB也喜欢${love2}\n表达式可以是任何有意义的数据${1 + 3 * 2 / 0.5}\n表达式是可以嵌套的：${`表达式中的模板字符串${love1 + love2}`}\n\\n\\n\n奥布瓦的发顺丰\n在模板字符串中使用\\${JS表达式}可以进行插值\n`;\n\nconsole.log(text);\n')])])]),t("p",[n._v("在模板字符串书写之前，可以加上标记:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("标记名`模板字符串`\n")])])]),t("p",[n._v("标记是一个函数，函数参数如下：")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("参数1：被插值分割的字符串数组")])]),n._v(" "),t("li",[t("p",[n._v("后续参数：所有的插值")]),n._v(" "),t("p",[n._v('var love1 = "秋葵";\nvar love2 = "香菜";')]),n._v(" "),t("p",[n._v("var text = myTag"),t("code",[n._v("邓哥喜欢${love1}，邓哥也喜欢${love2}。")]),n._v(";")]),n._v(" "),t("p",[n._v('//相当于：\n// text = myTag(["A喜欢", "，B也喜欢", "。"], "秋葵", "香菜")')]),n._v(" "),t("p",[n._v('function myTag(parts) {\nconst values = Array.prototype.slice.apply(arguments).slice(1);\nlet str = "";\nfor (let i = 0; i < values.length; i++) {\nstr += '),t("code",[n._v("${parts[i]}：${values[i]}")]),n._v(";\nif (i === values.length - 1) {\nstr += parts[i + 1];\n}\n}\nreturn str;\n}")]),n._v(" "),t("p",[n._v("console.log(text); //A喜欢：秋葵，B也喜欢：香菜")])])]),n._v(" "),t("h1",{attrs:{id:"第五章、函数的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第五章、函数的扩展"}},[n._v("#")]),n._v(" 第五章、函数的扩展")]),n._v(" "),t("h2",{attrs:{id:"_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-在书写形参时，直接给形参赋值，附的值即为默认值（在解构的时候有过应用）"}},[n._v("#")]),n._v(" 1. 在书写形参时，直接给形参赋值，附的值即为"),t("strong",[n._v("默认值")]),n._v("（在解构的时候有过应用）")]),n._v(" "),t("p",[n._v("这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是undefined），则会自动使用默认值")]),n._v(" "),t("ol",[t("li",[n._v("留意暂时性死区 形参")])]),n._v(" "),t("ul",[t("li",[n._v("和ES6中的let或const声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。")])]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[n._v("对arguments的影响")])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("只要给函数加上参数默认值，该函数会自动变量严格模式下的规则：arguments和形参脱离")])]),n._v(" "),t("li",[t("p",[n._v("暂时性死区")]),n._v(" "),t("p",[n._v("function test(a = b, b) {\nconsole.log(a, b);\n}\ntest(undefined, 2);// 报错 因为传a值undefined, 然后会给a赋默认值 b ,但是此时 b还没有赋值，所以报错。在上边解构赋值中也介绍过")]),n._v(" "),t("p",[n._v("function sum(a, b = 1, c = 2) {\nreturn a + b + c;\n}")]),n._v(" "),t("p",[n._v("console.log(sum(10, undefined, undefined))\nconsole.log(sum(11))\nconsole.log(sum(1, undefined, 5))  // 这种情况才是正常")])]),n._v(" "),t("li",[t("p",[n._v("对arguments的影响")]),n._v(" "),t("p",[n._v('function test(a, b = 1) {\nconsole.log("arugments", arguments[0], arguments[1]); //arugments 1 2\nconsole.log("a:", a, "b:", b); //a: 1 b: 2\na = 3;\nconsole.log("arugments", arguments[0], arguments[1]); //arugments 1 2\nconsole.log("a:", a, "b:", b); //a: 3 b: 2\n}')]),n._v(" "),t("p",[n._v("test(1, 2);")])])]),n._v(" "),t("h2",{attrs:{id:"es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法"}},[n._v("#")]),n._v(" ES6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。语法:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("function (...形参名){\n\n}\n")])])]),t("p",[t("strong",[n._v("注意：")])]),n._v(" "),t("ol",[t("li",[t("p",[n._v("一个函数，仅能出现一个剩余参数")])]),n._v(" "),t("li",[t("p",[n._v("一个函数，如果有剩余参数，剩余参数必须是最后一个参数")]),n._v(" "),t("p",[n._v("function test(a, b, ...args) {\nconsole.log(a, b, args);\n}")]),n._v(" "),t("p",[n._v("test(1, 32, 46, 7, 34); //1 32 [46, 7, 34]")])])]),n._v(" "),t("h2",{attrs:{id:"_2-展开运算符：-要展开的东西"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-展开运算符：-要展开的东西"}},[n._v("#")]),n._v(" 2. 展开运算符："),t("code",[n._v("...要展开的东西")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('const arr1 = [3, 67, 8, 5];\n\n//克隆arr1数组到arr2\n\nconst arr2 = [0, ...arr1, 1];\n\nconsole.log(arr2, arr1 === arr2)\n// -------------------------------------\nconst obj1 = {\n    name: "A",\n    age: 18,\n    love: "B",\n    address: {\n        country: "中国",\n        province: "BJ",\n        city: "BJ"\n    }\n}\n\n// 浅克隆到obj2\n\nconst obj2 = {\n    ...obj1,\n    name: "C"\n};\n\nconsole.log(obj2)\n\nconsole.log(obj1.address === obj2.address)\n')])])]),t("h2",{attrs:{id:"_3-明确函数的双重用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-明确函数的双重用途"}},[n._v("#")]),n._v(" 3. 明确函数的双重用途")]),n._v(" "),t("p",[n._v("ES6提供了一个特殊的API，可以使用该API在函数内部，判断该函数是否使用了new来调用")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('new.target \n//该表达式，得到的是：如果没有使用new来调用函数，则返回undefined\n//如果使用new调用函数，则得到的是new关键字后面的函数本身\n\nfunction Person(firstName, lastName) {\n    //判断是否是使用new的方式来调用的函数\n\n    // //过去的判断方式\n    // if (!(this instanceof Person)) {\n    //     throw new Error("该函数没有使用new来调用")\n    // }\n\n    if (new.target === undefined) {\n        throw new Error("该函数没有使用new来调用")\n    }\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.fullName = `${firstName} ${lastName}`;\n}\n\nconst p1 = new Person("张", "三");\nconsole.log(p1)\n\n\n\nconst p2 = Person("张", "三");\nconsole.log(p2); // 报错，该函数没有使用new来调用\n\nconst p3 = Person.call(p1, "张", "三")\nconsole.log(p3);// 报错，该函数没有使用new来调用\n')])])]),t("h2",{attrs:{id:"_4-箭头函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-箭头函数"}},[n._v("#")]),n._v(" 4. 箭头函数")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("ES5中this的问题（本文主要是来介绍ES6的，暂且将之前的总结直接放在这里，在之后的博文中会仔细描述一下ES5系列）")]),n._v(" "),t("ol",[t("li",[n._v("通过对象调用函数，this指向对象")]),n._v(" "),t("li",[n._v("直接调用函数，this指向全局对象")]),n._v(" "),t("li",[n._v("如果通过new调用函数，this指向新创建的对象")]),n._v(" "),t("li",[n._v("如果通过apply、call、bind调用函数，this指向指定的数据")]),n._v(" "),t("li",[n._v("如果是DOM事件函数，this指向事件源")])])]),n._v(" "),t("li",[t("p",[n._v("箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数")])])]),n._v(" "),t("p",[n._v("完整语法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("(参数1, 参数2, ...)=>{\n    //函数体\n}\n")])])]),t("p",[n._v("如果参数只有一个，可以省略小括号")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("参数 => {\n\n}\n")])])]),t("p",[n._v("如果箭头函数只有一条返回语句，可以省略大括号，和return关键字")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('参数 => 返回值\n\n\nconst print = num => {\n    console.log("给我的数字是：", num)\n}\nprint(2);\n\nconst arr = [1,2,4,56,22,43,23,2,23,12,1];\narr.sort((a, b)=> a - b);\nconsole.log(arr);\n')])])]),t("p",[t("strong",[n._v("注意")])]),n._v(" "),t("ul",[t("li",[t("p",[n._v("箭头函数中，不存在this、arguments、new.target，如果使用了，则使用的是函数外层的对应的this、arguments、new.target 也就是说"),t("strong",[n._v("在箭头函数中，this是固定的。因为箭头函数本身就是引用的外层函数的this")])])]),n._v(" "),t("li",[t("p",[n._v("箭头函数没有原型")])]),n._v(" "),t("li",[t("p",[n._v("箭头函数不能作用构造函数使用")])]),n._v(" "),t("li",[t("p",[n._v("不可以使用yield命令，因此箭头函数不能用作 Generator 函数")]),n._v(" "),t("p",[n._v("// ES6\nfunction foo() {\nsetTimeout(() => {\nconsole.log('id:', this.id);\n}, 100);\n}")]),n._v(" "),t("p",[n._v("// ES5\nfunction foo() {\nvar _this = this;")]),n._v(" "),t("p",[n._v("setTimeout(function () {\nconsole.log('id:', _this.id);\n}, 100);\n}")])])]),n._v(" "),t("p",[n._v("除了this，arguments、super、new.target这三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("function foo() {\n  setTimeout(() => {\n    console.log('args:', arguments);\n  }, 100);\n}\n\nfoo(2, 4, 6, 8)\n// args: [2, 4, 6, 8]\n")])])]),t("p",[n._v("另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("(function() {\n  return [\n    (() => this.x).bind({ x: 'inner' })()\n  ];\n}).call({ x: 'outer' });\n// ['outer']\n//代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。\n")])])]),t("p",[t("strong",[n._v("应用比较多的场景")])]),n._v(" "),t("ol",[t("li",[n._v("临时性使用的函数，并不会可以调用它，比如：\n"),t("ol",[t("li",[n._v("事件处理函数")]),n._v(" "),t("li",[n._v("异步处理函数")]),n._v(" "),t("li",[n._v("其他临时性的函数")])])]),n._v(" "),t("li",[n._v("为了绑定外层this的函数")]),n._v(" "),t("li",[n._v("在不影响其他代码的情况下，保持代码的简洁，最常见的，数组方法中的回调函数")])]),n._v(" "),t("p",[n._v("本文主要引用阮一峰老师的《ECMAScript6简介》")])])},v=[]},352:function(n,e,t){"use strict";t.r(e);var a=t(351),v=t(317);for(var s in v)"default"!==s&&function(n){t.d(e,n,(function(){return v[n]}))}(s);var r=t(43),_=Object(r.a)(v.default,a.a,a.b,!1,null,null,null);e.default=_.exports}}]);