(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{364:function(e,n,t){"use strict";t.r(n);var a=t(43),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue相关"}},[e._v("#")]),e._v(" vue相关")]),e._v(" "),t("h2",{attrs:{id:"_1-require-context"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-require-context"}},[e._v("#")]),e._v(" 1.require.context()")]),e._v(" "),t("p",[e._v("1.场景:如页面需要导入多个组件,原始写法:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import titleCom from '@/components/home/titleCom'\nimport bannerCom from '@/components/home/bannerCom'\nimport cellCom from '@/components/home/cellCom'\ncomponents:{titleCom,bannerCom,cellCom}\n")])])]),t("p",[e._v("2.这样就写了大量重复的代码,利用 require.context 可以写成")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const path = require('path')\nconst files = require.context('@/components/home', false, /\\.vue$/)\nconst modules = {}\nfiles.keys().forEach(key => {\nconst name = path.basename(key, '.vue')\nmodules[name] = files(key).default || files(key)\n})\ncomponents:modules\n")])])]),t("p",[e._v("这样不管页面引入多少组件,都可以使用这个方法")]),e._v(" "),t("p",[e._v("3.API 方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用\nrequire.context(directory,useSubdirectories,regExp)\n接收三个参数:\ndirectory：说明需要检索的目录\nuseSubdirectories：是否检索子目录\nregExp: 匹配文件的正则表达式,一般是文件名\n")])])]),t("h2",{attrs:{id:"_2-watch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-watch"}},[e._v("#")]),e._v(" 2.watch")]),e._v(" "),t("p",[e._v("2.1 常用用法\n1.场景:表格初始进来需要调查询接口 getList(),然后input 改变会重新查询")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("created(){\n  this.getList()\n},\nwatch: {\n  inpVal(){\n    this.getList()\n  }\n}\n")])])]),t("p",[e._v("2.2 立即执行\n2.可以直接利用 watch 的immediate和handler属性简写")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("watch: {\n  inpVal:{\n    handler: 'getList',\n      immediate: true\n  }\n}\n")])])]),t("p",[e._v("2.3 深度监听\n3.watch 的 deep 属性,深度监听,也就是监听复杂数据类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("watch:{\n  inpValObj:{\n    handler(newVal,oldVal){\n      console.log(newVal)\n      console.log(oldVal)\n    },\n    deep:true\n  }\n}\n")])])]),t("p",[e._v("此时发现oldVal和 newVal 值一样; 因为它们索引同一个对象/数组,Vue 不会保留修改之前值的副本; 所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化")]),e._v(" "),t("h2",{attrs:{id:"_3-11种组件通讯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-11种组件通讯"}},[e._v("#")]),e._v(" 3. 11种组件通讯")]),e._v(" "),t("h2",{attrs:{id:"_3-1-props"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-props"}},[e._v("#")]),e._v(" 3.1 props")]),e._v(" "),t("p",[e._v("这个应该非常属性,就是父传子的属性; props 值可以是一个数组或对象;")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 数组:不建议使用\nprops:[]\n\n// 对象\nprops:{\n inpVal:{\n  type:Number, //传入值限定类型\n  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol\n  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n  required: true, //是否必传\n  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=>[]\n  validator:(value) {\n    // 这个值必须匹配下列字符串中的一个\n    return ['success', 'warning', 'danger'].indexOf(value) == -1\n  }\n }\n}\n")])])]),t("h2",{attrs:{id:"_3-2-emit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-emit"}},[e._v("#")]),e._v(" 3.2 $emit")]),e._v(" "),t("p",[e._v("这个也应该非常常见,触发子组件触发父组件给自己绑定的事件,其实就是子传父的方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 父组件\n<home @title=\"title\">\n// 子组件\nthis.$emit('title',[{title:'这是title'}])\n")])])]),t("h2",{attrs:{id:"_3-3-vuex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-vuex"}},[e._v("#")]),e._v(" 3.3 vuex")]),e._v(" "),t("p",[e._v("1.这个也是很常用的,vuex 是一个状态管理器 2.是一个独立的插件,适合数据共享多的项目里面,因为如果只是简单的通讯,使用起来会比较重 3.API")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("state:定义存贮数据的仓库 ,可通过this.$store.state 或mapState访问\ngetter:获取 store 值,可认为是 store 的计算属性,可通过this.$store.getter 或\n       mapGetters访问\nmutation:同步改变 store 值,为什么会设计成同步,因为mutation是直接改变 store 值,\n         vue 对操作进行了记录,如果是异步无法追踪改变.可通过mapMutations调用\naction:异步调用函数执行mutation,进而改变 store 值,可通过 this.$dispatch或mapActions\n       访问\nmodules:模块,如果状态过多,可以拆分成模块,最后在入口通过...解构引入\n")])])]),t("h2",{attrs:{id:"_3-4-attrs和listeners"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-attrs和listeners"}},[e._v("#")]),e._v(" 3.4 attrs和listeners")]),e._v(" "),t("p",[e._v("2.4.0 新增 这两个是不常用属性,但是高级用法很常见; 1.attrs\n场景:如果父传子有很多值,那么在子组件需要定义多个 props\n解决:attrs获取子传父中未在 props 定义的值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 父组件\n<home title="这是标题" width="80" height="80" imgUrl="imgUrl"/>\n\n// 子组件\nmounted() {\n  console.log(this.$attrs) //{title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"}\n},\n')])])]),t("p",[e._v("相对应的如果子组件定义了 props,打印的值就是剔除定义的属性")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('props: {\n  width: {\n    type: String,\n    default: \'\'\n  }\n},\nmounted() {\n  console.log(this.$attrs) //{title: "这是标题", height: "80", imgUrl: "imgUrl"}\n},\n')])])]),t("p",[e._v('2.listeners\n场景:子组件需要调用父组件的方法\n解决:父组件的方法可以通过 v-on="listeners" 传入内部组件——在创建更高层次的组件时非常有用')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 父组件\n<home @change="change"/>\n\n// 子组件\nmounted() {\n  console.log(this.$listeners) //即可拿到 change 事件\n}\n')])])]),t("p",[e._v("如果是孙组件要访问父组件的属性和调用方法,直接一级一级传下去就可以")]),e._v(" "),t("p",[e._v("3.inheritAttrs")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 父组件\n<home title="这是标题" width="80" height="80" imgUrl="imgUrl"/>\n\n// 子组件\nmounted() {\n  console.log(this.$attrs) //{title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"}\n},\n\ninheritAttrs默认值为true，true的意思是将父组件中除了props外的属性添加到子组件的根节点上(说明，即使设置为true，子组件仍然可以通过$attr获取到props意外的属性)\n将inheritAttrs:false后,属性就不会显示在根节点上了\n')])])]),t("h2",{attrs:{id:"_3-5-provide和inject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-provide和inject"}},[e._v("#")]),e._v(" 3.5 provide和inject")]),e._v(" "),t("p",[e._v("2.2.0 新增 描述: provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中; 并且这对选项需要一起使用; 以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//父组件:\nprovide: { //provide 是一个对象,提供一个属性或方法\n  foo: '这是 foo',\n  fooMethod:()=>{\n    console.log('父组件 fooMethod 被调用')\n  }\n},\n\n// 子或者孙子组件\ninject: ['foo','fooMethod'], //数组或者对象,注入到子组件\nmounted() {\n  this.fooMethod()\n  console.log(this.foo)\n}\n//在父组件下面所有的子组件都可以利用inject\n")])])]),t("p",[e._v("provide 和 inject 绑定并不是可响应的。这是官方刻意为之的。 然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的,对象是因为是引用类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//父组件:\nprovide: { \n  foo: '这是 foo'\n},\nmounted(){\n  this.foo='这是新的 foo'\n}\n\n// 子或者孙子组件\ninject: ['foo'], \nmounted() {\n  console.log(this.foo) //子组件打印的还是'这是 foo'\n}\n")])])]),t("h2",{attrs:{id:"_3-6-parent和children"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-parent和children"}},[e._v("#")]),e._v(" 3.6 parent和children")]),e._v(" "),t("p",[e._v("parent:父实例children:子实例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//父组件\nmounted(){\n  console.log(this.$children) \n  //可以拿到 一级子组件的属性和方法\n  //所以就可以直接改变 data,或者调用 methods 方法\n}\n\n//子组件\nmounted(){\n  console.log(this.$parent) //可以拿到 parent 的属性和方法\n}\n")])])]),t("p",[e._v("children和parent 并不保证顺序，也不是响应式的 只能拿到一级父组件和子组件")]),e._v(" "),t("h2",{attrs:{id:"_3-7-refs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-refs"}},[e._v("#")]),e._v(" 3.7 $refs")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 父组件\n<home ref="home"/>\n\nmounted(){\n  console.log(this.$refs.home) //即可拿到子组件的实例,就可以直接操作 data 和 methods\n}\n')])])]),t("h2",{attrs:{id:"_3-8-root"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-root"}},[e._v("#")]),e._v(" 3.8 $root")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 父组件\nmounted(){\n  console.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上\n  console.log(this.$root.$children[0]) //获取根实例的一级子组件\n  console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件\n}\n")])])]),t("h2",{attrs:{id:"_3-9-sync"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-sync"}},[e._v("#")]),e._v(" 3.9 .sync")]),e._v(" "),t("p",[e._v("在 vue@1.x 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值; 在 vue@2.0 的由于违背单项数据流的设计被干掉了; 在 vue@2.3.0+ 以上版本又重新引入了这个 .sync 修饰符;")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 父组件\n<home :title.sync="title" />\n//编译时会被扩展为\n<home :title="title"  @update:title="val => title = val"/>\n\n// 子组件\n// 所以子组件可以通过$emit 触发 update 方法改变\nmounted(){\n  this.$emit("update:title", \'这是新的title\')\n}\n')])])]),t("h2",{attrs:{id:"_3-10-eventbus"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-10-eventbus"}},[e._v("#")]),e._v(" 3.10 EventBus")]),e._v(" "),t("p",[e._v("1.就是声明一个全局Vue实例变量 EventBus , 把所有的通信数据，事件监听都存储到这个变量上; 2.类似于 Vuex。但这种方式只适用于极小的项目 3.原理就是利用!on和emit 并实例化一个全局 vue 实现数据共享")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 在 main.js\nVue.prototype.$eventBus=new Vue()\n\n// 传值组件\nthis.$eventBus.$emit('eventTarget','这是eventTarget传过来的值')\n\n// 接收组件\nthis.$eventBus.$on(\"eventTarget\",v=>{\n  console.log('eventTarget',v);//这是eventTarget传过来的值\n})\n")])])]),t("p",[e._v("4.可以实现平级,嵌套组件传值,但是对应的事件名eventTarget必须是全局唯一的")]),e._v(" "),t("h2",{attrs:{id:"_3-11-路由传参"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-11-路由传参"}},[e._v("#")]),e._v(" 3.11 路由传参")]),e._v(" "),t("p",[e._v("1.方案一")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 路由定义\n{\n  path: '/describe/:id',\n  name: 'Describe',\n  component: Describe\n}\n// 页面传参\nthis.$router.push({\n  path: `/describe/${id}`,\n})\n// 页面获取\nthis.$route.params.id\n")])])]),t("p",[e._v("2.方案二")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 路由定义\n{\n  path: '/describe',\n  name: 'Describe',\n  component: Describe\n}\n// 页面传参\nthis.$router.push({\n  name: 'Describe',\n  params: {\n    id: id\n  }\n})\n// 页面获取\nthis.$route.params.id\n")])])]),t("p",[e._v("3.方案三")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 路由定义\n{\n  path: '/describe',\n  name: 'Describe',\n  component: Describe\n}\n// 页面传参\nthis.$router.push({\n  path: '/describe',\n    query: {\n      id: id\n  `}\n)\n// 页面获取\nthis.$route.query.id\n")])])]),t("p",[e._v("4.三种方案对比 方案二参数不会拼接在路由后面,页面刷新参数会丢失 方案一和三参数拼接在后面,丑,而且暴露了信息")]),e._v(" "),t("h2",{attrs:{id:"_4-render-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-render-函数"}},[e._v("#")]),e._v(" 4.render 函数")]),e._v(" "),t("p",[e._v("1.场景:有些代码在 template 里面写会重复很多,所以这个时候 render 函数就有作用啦")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 根据 props 生成标签\n// 初级\n<template>\n  <div>\n    <div v-if=\"level === 1\"> <slot></slot> </div>\n    <p v-else-if=\"level === 2\"> <slot></slot> </p>\n    <h1 v-else-if=\"level === 3\"> <slot></slot> </h1>\n    <h2 v-else-if=\"level === 4\"> <slot></slot> </h2>\n    <strong v-else-if=\"level === 5\"> <slot></slot> </stong>\n    <textarea v-else-if=\"level === 6\"> <slot></slot> </textarea>\n  </div>\n</template>\n\n// 优化版,利用 render 函数减小了代码重复率\n<template>\n  <div>\n    <child :level=\"level\">Hello world!</child>\n  </div>\n</template>\n\n<script type='text/javascript'>\n  import Vue from 'vue'\n  Vue.component('child', {\n    render(h) {\n      const tag = ['div', 'p', 'strong', 'h1', 'h2', 'textarea'][this.level-1]\n      return h(tag, this.$slots.default)\n    },\n    props: {\n      level: {  type: Number,  required: true  } \n    }\n  })   \n  export default {\n    name: 'hehe',\n    data() { return { level: 3 } }\n  }\n<\/script>\n")])])]),t("p",[e._v("2.render 和 template 的对比 前者适合复杂逻辑,后者适合逻辑简单; 后者属于声明是渲染，前者属于自定Render函数; 前者的性能较高，后者性能较低。")]),e._v(" "),t("h2",{attrs:{id:"_5-异步组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步组件"}},[e._v("#")]),e._v(" 5.异步组件")]),e._v(" "),t("p",[e._v("场景:项目过大就会导致加载缓慢,所以异步组件实现按需加载就是必须要做的事啦 1.异步注册组件 3种方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 工厂函数执行 resolve 回调\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包, 这些包\n  // 会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve)\n})\n\n// 工厂函数返回 Promise\nVue.component(\n  'async-webpack-example',\n  // 这个 `import` 函数会返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n\n// 工厂函数返回一个配置化组件对象\nconst AsyncComponent = () => ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n})\n")])])]),t("p",[e._v("异步组件的渲染本质上其实就是执行2次或者2次以上的渲染, 先把当前组件渲染为注释节点, 当组件加载成功后, 通过 forceRender 执行重新渲染。或者是渲染为注释节点, 然后再渲染为loading节点, 在渲染为请求完成的组件")]),e._v(" "),t("p",[e._v("2.路由的按需加载")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("webpack< 2.4 时\n{\n  path:'/',\n  name:'home',\n  components:resolve=>require(['@/components/home'],resolve)\n}\n\nwebpack> 2.4 时\n{\n  path:'/',\n  name:'home',\n  components:()=>import('@/components/home')\n}\n\nimport()方法由es6提出，import()方法是动态加载，返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。\n")])])]),t("h2",{attrs:{id:"_6-动态组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-动态组件"}},[e._v("#")]),e._v(" 6.动态组件")]),e._v(" "),t("p",[e._v("场景:做一个 tab 切换时就会涉及到组件动态加载")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<component v-bind:is="currentTabComponent"></component>\n')])])]),t("p",[e._v("但是这样每次组件都会重新加载,会消耗大量性能,所以 就起到了作用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<keep-alive>\n    <component v-bind:is="currentTabComponent"></component>\n</keep-alive>\n')])])]),t("p",[e._v("这样切换效果没有动画效果,这个也不用着急,可以利用内置的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<transition>\n    <keep-alive>\n        <component v-bind:is="currentTabComponent"></component>\n    </keep-alive>\n</transition>\n')])])]),t("h2",{attrs:{id:"_7-递归组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-递归组件"}},[e._v("#")]),e._v(" 7.递归组件")]),e._v(" "),t("p",[e._v("场景:如果开发一个 tree 组件,里面层级是根据后台数据决定的,这个时候就需要用到动态组件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 递归组件: 组件在它的模板内可以递归的调用自己，只要给组件设置name组件就可以了。\n// 设置那么House在组件模板内就可以递归使用了,不过需要注意的是，\n// 必须给一个条件来限制数量，否则会抛出错误: max stack size exceeded\n// 组件递归用来开发一些具体有未知层级关系的独立组件。比如：\n// 联级选择器和树形控件 \n\n<template>\n  <div v-for="(item,index) in treeArr">\n      子组件，当前层级值： '+e._s(e.index)+' <br/>\n      \x3c!-- 递归调用自身, 后台判断是否不存在改值 --\x3e\n      <tree :item="item.arr" v-if="item.flag"></tree>\n  </div>\n</template>\n<script>\nexport default {\n  // 必须定义name，组件内部才能递归调用\n  name: \'tree\',\n  data(){\n    return {}\n  },\n  // 接收外部传入的值\n  props: {\n     item: {\n      type:Array,\n      default: ()=>[]\n    }\n  }\n}\n<\/script>\n')])])]),t("p",[e._v("递归组件必须设置name 和结束的阀值")]),e._v(" "),t("h2",{attrs:{id:"_8-函数式组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-函数式组件"}},[e._v("#")]),e._v(" 8.函数式组件")]),e._v(" "),t("p",[e._v("定义:无状态,无法实例化，内部没有任何生命周期处理方法 规则:在 2.3.0 之前的版本中，如果一个函数式组件想要接收 prop，则 props 选项是必须的。 在 2.3.0 或以上的版本中，你可以省略 props 选项，所有组件上的特性都会被自动隐式解析为 prop 在 2.5.0 及以上版本中，如果你使用了单文件组件(就是普通的.vue 文件),可以直接在 template 上声明functional 组件需要的一切都是通过 context 参数传递")]),e._v(" "),t("p",[e._v("context 属性有: 1.props：提供所有 prop 的对象 2.children: VNode 子节点的数组 3.slots: 一个函数，返回了包含所有插槽的对象 4.scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。 5.data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件 6.parent：对父组件的引用 7.listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。 8.injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<template functional>\n  <div v-for="(item,index) in props.arr">'+e._s(e.item)+"</div>\n</template>\n")])])]),t("h2",{attrs:{id:"_9-components和-vue-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-components和-vue-component"}},[e._v("#")]),e._v(" 9.components和 Vue.component")]),e._v(" "),t("p",[e._v("components:局部注册组件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("export default{\n  components:{home}\n}\n")])])]),t("p",[e._v("Vue.component:全局注册组件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Vue.component('home',home)\n")])])]),t("h2",{attrs:{id:"_10-vue-extend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-extend"}},[e._v("#")]),e._v(" 10.Vue.extend")]),e._v(" "),t("p",[e._v("场景:vue 组件中有些需要将一些元素挂载到元素上,这个时候 extend 就起到作用了 是构造一个组件的语法器 写法:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 创建构造器\nvar Profile = Vue.extend({\n  template: '<p>"+e._s(e.extendData)+"</br>实例传入的数据为:"+e._s(e.propsExtend)+"</p>',//template对应的标签最外层必须只有一个标签\n  data: function () {\n    return {\n      extendData: '这是extend扩展的数据',\n    }\n  },\n  props:['propsExtend']\n})\n\n// 创建的构造器可以挂载到元素上,也可以通过 components 或 Vue.component()注册使用\n// 挂载到一个元素上。可以通过propsData传参.\nnew Profile({propsData:{propsExtend:'我是实例传入的数据'}}).$mount('#app-extend')\n\n// 通过 components 或 Vue.component()注册\nVue.component('Profile',Profile)\n")])])]),t("h2",{attrs:{id:"_11-mixins"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-mixins"}},[e._v("#")]),e._v(" 11.mixins")]),e._v(" "),t("p",[e._v("场景:有些组件有些重复的 js 逻辑,如校验手机验证码,解析时间等,mixins 就可以实现这种混入 mixins 值是一个数组")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const mixin={\n    created(){\n      this.dealTime()\n    },\n    methods:{\n      dealTime(){\n        console.log('这是mixin的dealTime里面的方法');\n      }\n  }\n}\n\nexport default{\n  mixins:[mixin]\n}\n")])])]),t("h2",{attrs:{id:"_12-extends"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-extends"}},[e._v("#")]),e._v(" 12.extends")]),e._v(" "),t("p",[e._v("extends用法和mixins很相似,只不过接收的参数是简单的选项对象或构造函数,所以extends只能单次扩展一个组件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const extend={\n    created(){\n      this.dealTime()\n    },\n    methods:{\n      dealTime(){\n        console.log('这是mixin的dealTime里面的方法');\n      }\n  }\n}\n\nexport default{\n  extends:extend\n}\n")])])]),t("h2",{attrs:{id:"_13-vue-use"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-use"}},[e._v("#")]),e._v(" 13.Vue.use()")]),e._v(" "),t("p",[e._v("场景:我们使用 element时会先 import,再 Vue.use()一下,实际上就是注册组件,触发 install 方法; 这个在组件调用会经常使用到; 会自动组织多次注册相同的插件.")]),e._v(" "),t("h2",{attrs:{id:"_14-install"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-install"}},[e._v("#")]),e._v(" 14.install")]),e._v(" "),t("p",[e._v("场景:在 Vue.use()说到,执行该方法会触发 install 是开发vue的插件,这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象(可选)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("var MyPlugin = {};\n  MyPlugin.install = function (Vue, options) {\n    // 2. 添加全局资源,第二个参数传一个值默认是update对应的值\n    Vue.directive('click', {\n      bind(el, binding, vnode, oldVnode) {\n        //做绑定的准备工作,添加时间监听\n        console.log('指令my-directive的bind执行啦');\n      },\n      inserted: function(el){\n      //获取绑定的元素\n      console.log('指令my-directive的inserted执行啦');\n      },\n      update: function(){\n      //根据获得的新值执行对应的更新\n      //对于初始值也会调用一次\n      console.log('指令my-directive的update执行啦');\n      },\n      componentUpdated: function(){\n      console.log('指令my-directive的componentUpdated执行啦');\n      },\n      unbind: function(){\n      //做清理操作\n      //比如移除bind时绑定的事件监听器\n      console.log('指令my-directive的unbind执行啦');\n      }\n    })\n\n    // 3. 注入组件\n    Vue.mixin({\n      created: function () {\n        console.log('注入组件的created被调用啦');\n        console.log('options的值为',options)\n      }\n    })\n\n    // 4. 添加实例方法\n    Vue.prototype.$myMethod = function (methodOptions) {\n      console.log('实例方法myMethod被调用啦');\n    }\n  }\n\n  //调用MyPlugin\n  Vue.use(MyPlugin,{someOption: true })\n\n  //3.挂载\n  new Vue({\n    el: '#app'\n  });\n")])])]),t("p",[e._v("更多请戳 vue中extend，mixins，extends，components,install的几个操作")]),e._v(" "),t("h2",{attrs:{id:"_15-vue-nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-vue-nexttick"}},[e._v("#")]),e._v(" 15.Vue.nextTick")]),e._v(" "),t("p",[e._v("2.1.0 新增 场景:页面加载时需要让文本框获取焦点 用法:在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("mounted(){ //因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick\n  this.$nextTick(() => {\n    this.$refs.inputs.focus() //通过 $refs 获取dom 并绑定 focus 方法\n  })\n}\n")])])]),t("h2",{attrs:{id:"_16-vue-directive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-vue-directive"}},[e._v("#")]),e._v(" 16.Vue.directive")]),e._v(" "),t("p",[e._v("16.1 使用场景:\n官方给我们提供了很多指令,但是我们如果想将文字变成指定的颜色定义成指令使用,这个时候就需要用到Vue.directive")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 全局定义\nVue.directive("change-color",function(el,binding,vnode){\n  el.style["color"]= binding.value;\n})\n\n// 使用\n<template>\n<div v-change-color=“color”>'+e._s(e.message)+"</div>\n</template>\n<script>\n  export default{\n    data(){\n      return{\n        color:'green'\n      }\n    }\n  }\n<\/script>\n")])])]),t("p",[e._v("16.2 生命周期\n1.bind 只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。 2.inserted:被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中) 3.update: 被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新 4.componentUpdate :被绑定的元素所在模板完成一次更新更新周期的时候调用 5.unbind: 只调用一次，指令月元素解绑的时候调用")]),e._v(" "),t("h2",{attrs:{id:"_17-vue-filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-vue-filter"}},[e._v("#")]),e._v(" 17.Vue.filter")]),e._v(" "),t("p",[e._v("场景:时间戳转化成年月日这是一个公共方法,所以可以抽离成过滤器使用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 使用\n// 在双花括号中\n"+e._s(e._f("capitalize")(e.message))+"\n\n// 在 `v-bind` 中\n<div v-bind:id=\"rawId | formatId\"></div>\n\n// 全局注册\nVue.filter('stampToYYMMDD', (value) =>{\n  // 处理逻辑\n})\n\n// 局部注册\nfilters: {\n  stampToYYMMDD: (value)=> {\n    // 处理逻辑\n  }\n}\n\n// 多个过滤器全局注册\n// /src/common/filters.js\nlet dateServer = value => value.replace(/(\\d{4})(\\d{2})(\\d{2})/g, '$1-$2-$3') \nexport { dateServer }\n// /src/main.js\nimport * as custom from './common/filters/custom'\nObject.keys(custom).forEach(key => Vue.filter(key, custom[key]))\n")])])]),t("h2",{attrs:{id:"_18-vue-compile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-vue-compile"}},[e._v("#")]),e._v(" 18.Vue.compile")]),e._v(" "),t("p",[e._v("场景:在 render 函数中编译模板字符串。只在独立构建时有效")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("var res = Vue.compile('<div><span>"+e._s(e.msg)+"</span></div>')\n\nnew Vue({\n  data: {\n    msg: 'hello'\n  },\n  render: res.render,\n  staticRenderFns: res.staticRenderFns\n})\n")])])]),t("h2",{attrs:{id:"_19-vue-version"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue-version"}},[e._v("#")]),e._v(" 19.Vue.version")]),e._v(" "),t("p",[e._v("场景:有些开发插件需要针对不同 vue 版本做兼容,所以就会用到 Vue.version 用法:Vue.version()可以获取 vue 版本")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("var version = Number(Vue.version.split('.')[0])\n\nif (version === 2) {\n  // Vue v2.x.x\n} else if (version === 1) {\n  // Vue v1.x.x\n} else {\n  // Unsupported versions of Vue\n}\n")])])]),t("h2",{attrs:{id:"_20-vue-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-vue-set"}},[e._v("#")]),e._v(" 20.Vue.set()")]),e._v(" "),t("p",[e._v("场景:当你利用索引直接设置一个数组项时或你修改数组的长度时,由于 Object.defineprototype()方法限制,数据不响应式更新 不过vue.3.x 将利用 proxy 这个问题将得到解决 解决方案:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 利用 set\nthis.$set(arr,index,item)\n\n// 利用数组 push(),splice()   \n")])])]),t("h2",{attrs:{id:"_21-vue-config-keycodes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-vue-config-keycodes"}},[e._v("#")]),e._v(" 21.Vue.config.keyCodes")]),e._v(" "),t("p",[e._v("场景:自定义按键修饰符别名")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 将键码为 113 定义为 f2\nVue.config.keyCodes.f2 = 113;\n<input type="text" @keyup.f2="add"/>\n')])])]),t("h2",{attrs:{id:"_22-vue-config-performance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22-vue-config-performance"}},[e._v("#")]),e._v(" 22.Vue.config.performance")]),e._v(" "),t("p",[e._v("场景:监听性能")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Vue.config.performance = true\n")])])]),t("p",[e._v("只适用于开发模式和支持 performance.mark API 的浏览器上")]),e._v(" "),t("h2",{attrs:{id:"_23-vue-config-errorhandler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23-vue-config-errorhandler"}},[e._v("#")]),e._v(" 23.Vue.config.errorHandler")]),e._v(" "),t("p",[e._v("1.场景:指定组件的渲染和观察期间未捕获错误的处理函数 2.规则: 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了 从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理 3.使用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Vue.config.errorHandler = function (err, vm, info) {\n  // handle error\n  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\n  // 只在 2.2.0+ 可用\n}\n")])])]),t("h2",{attrs:{id:"_24-vue-config-warnhandler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24-vue-config-warnhandler"}},[e._v("#")]),e._v(" 24.Vue.config.warnHandler")]),e._v(" "),t("p",[e._v("2.4.0 新增 1.场景:为 Vue 的运行时警告赋予一个自定义处理函数,只会在开发者环境下生效 2.用法:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Vue.config.warnHandler = function (msg, vm, trace) {\n  // `trace` 是组件的继承关系追踪\n}\n")])])]),t("h2",{attrs:{id:"_25-v-once"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25-v-once"}},[e._v("#")]),e._v(" 25.v-once")]),e._v(" "),t("p",[e._v("场景:有些 template 中的静态 dom 没有改变,这时就只需要渲染一次,可以降低性能开销")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("<span v-once> 这时只需要加载一次的标签</span>\n")])])]),t("p",[e._v("v-once 和 v-pre 的区别: v-once只渲染一次；v-pre不编译,原样输出")]),e._v(" "),t("h2",{attrs:{id:"_26-事件修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26-事件修饰符"}},[e._v("#")]),e._v(" 26.事件修饰符")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(".stop:阻止冒泡\n.prevent:阻止默认行为\n.self:仅绑定元素自身触发\n.once: 2.1.4 新增,只触发一次\n.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用\n")])])]),t("h2",{attrs:{id:"_27-按键修饰符和按键码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27-按键修饰符和按键码"}},[e._v("#")]),e._v(" 27.按键修饰符和按键码")]),e._v(" "),t("p",[e._v("场景:有的时候需要监听键盘的行为,如按下 enter 去查询接口等")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 对应键盘上的关键字\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right\n")])])]),t("h2",{attrs:{id:"_28-vue-router"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28-vue-router"}},[e._v("#")]),e._v(" 28.Vue-router")]),e._v(" "),t("p",[e._v("场景:Vue-router 是官方提供的路由插件")]),e._v(" "),t("h2",{attrs:{id:"_29-object-freeze"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_29-object-freeze"}},[e._v("#")]),e._v(" 29.Object.freeze")]),e._v(" "),t("p",[e._v("场景:一个长列表数据,一般不会更改,但是vue会做getter和setter的转换 用法:是ES5新增的特性，可以冻结一个对象，防止对象被修改 支持:vue 1.0.18+对其提供了支持，对于data或vuex里使用freeze冻结了的对象，vue不会做getter和setter的转换 注意:冻结只是冻结里面的单个属性,引用地址还是可以更改")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("new Vue({\n    data: {\n        // vue不会对list里的object做getter、setter绑定\n        list: Object.freeze([\n            { value: 1 },\n            { value: 2 }\n        ])\n    },\n    mounted () {\n        // 界面不会有响应,因为单个属性被冻结\n        this.list[0].value = 100;\n\n        // 下面两种做法，界面都会响应\n        this.list = [\n            { value: 100 },\n            { value: 200 }\n        ];\n        this.list = Object.freeze([\n            { value: 100 },\n            { value: 200 }\n        ]);\n    }\n})\n")])])]),t("h2",{attrs:{id:"_30-为路径设置别名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_30-为路径设置别名"}},[e._v("#")]),e._v(" 30.为路径设置别名")]),e._v(" "),t("p",[e._v("1.场景:在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名")]),e._v(" "),t("p",[e._v("2.vue-cli 2.x 配置")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 在 webpack.base.config.js中的 resolve 配置项，在其 alias 中增加别名\nresolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n")])])]),t("p",[e._v("3.vue-cli 3.x 配置")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 在根目录下创建vue.config.js\nvar path = require('path')\nfunction resolve (dir) {\n  console.log(__dirname)\n  return path.join(__dirname, dir)\n}\nmodule.exports = {\n  chainWebpack: config => {\n    config.resolve.alias\n      .set(key, value) // key,value自行定义，比如.set('@@', resolve('src/components'))\n  }\n}")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);